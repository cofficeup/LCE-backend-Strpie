================================================================================
LAUNDRY CARE EXPRESS - COMPLETE SUBSCRIPTION SYSTEM CODE
Generated: Fri, Jan  2, 2026  3:24:44 PM
================================================================================

================================================================================
SECTION: app/Services
================================================================================

FILE: app/Services/Subscription/SubscriptionAnalyticsService.php
--------------------------------------------------------------------------------
<?php

namespace App\Services\Subscription;

use App\Models\UserSubscription;
use App\Models\Invoice;
use App\Models\SubscriptionPlan;
use Illuminate\Support\Facades\DB;
use Carbon\Carbon;

class SubscriptionAnalyticsService
{
    /**
     * Get revenue analytics by plan.
     */
    public function getRevenueByPlan(?Carbon $startDate = null, ?Carbon $endDate = null): array
    {
        $startDate = $startDate ?? Carbon::now()->startOfMonth();
        $endDate = $endDate ?? Carbon::now()->endOfMonth();

        $revenue = Invoice::select(
            'lce_subscription_plans.id as plan_id',
            'lce_subscription_plans.name as plan_name',
            DB::raw('COUNT(lce_invoices.id) as invoice_count'),
            DB::raw('SUM(lce_invoices.total) as total_revenue'),
            DB::raw('AVG(lce_invoices.total) as avg_invoice_amount')
        )
            ->join('lce_user_subscriptions', 'lce_invoices.subscription_id', '=', 'lce_user_subscriptions.id')
            ->join('lce_subscription_plans', 'lce_user_subscriptions.plan_id', '=', 'lce_subscription_plans.id')
            ->where('lce_invoices.status', 'paid')
            ->where('lce_invoices.type', 'subscription')
            ->whereBetween('lce_invoices.paid_at', [$startDate, $endDate])
            ->groupBy('lce_subscription_plans.id', 'lce_subscription_plans.name')
            ->get();

        $totalRevenue = $revenue->sum('total_revenue');

        return [
            'period' => [
                'start' => $startDate->toDateString(),
                'end' => $endDate->toDateString(),
            ],
            'total_revenue' => $totalRevenue,
            'by_plan' => $revenue->map(function ($item) use ($totalRevenue) {
                return [
                    'plan_id' => $item->plan_id,
                    'plan_name' => $item->plan_name,
                    'invoice_count' => $item->invoice_count,
                    'total_revenue' => round($item->total_revenue, 2),
                    'avg_invoice_amount' => round($item->avg_invoice_amount, 2),
                    'percentage' => $totalRevenue > 0 ? round(($item->total_revenue / $totalRevenue) * 100, 1) : 0,
                ];
            }),
        ];
    }

    /**
     * Get subscription status distribution.
     */
    public function getStatusDistribution(): array
    {
        $distribution = UserSubscription::select('status', DB::raw('COUNT(*) as count'))
            ->groupBy('status')
            ->get()
            ->pluck('count', 'status')
            ->toArray();

        $total = array_sum($distribution);

        return [
            'total' => $total,
            'active' => $distribution[UserSubscription::STATUS_ACTIVE] ?? 0,
            'pending' => $distribution[UserSubscription::STATUS_PENDING] ?? 0,
            'paused' => $distribution[UserSubscription::STATUS_PAUSED] ?? 0,
            'past_due' => $distribution[UserSubscription::STATUS_PAST_DUE] ?? 0,
            'cancelled' => $distribution[UserSubscription::STATUS_CANCELLED] ?? 0,
            'distribution' => collect($distribution)->map(function ($count) use ($total) {
                return [
                    'count' => $count,
                    'percentage' => $total > 0 ? round(($count / $total) * 100, 1) : 0,
                ];
            }),
        ];
    }

    /**
     * Calculate churn rate.
     * Churn = (Cancelled in period) / (Active at start of period) * 100
     */
    public function getChurnRate(?Carbon $startDate = null, ?Carbon $endDate = null): array
    {
        $startDate = $startDate ?? Carbon::now()->subMonth()->startOfMonth();
        $endDate = $endDate ?? Carbon::now()->subMonth()->endOfMonth();

        // Subscriptions active at start of period
        $activeAtStart = UserSubscription::where('created_at', '<', $startDate)
            ->whereIn('status', [
                UserSubscription::STATUS_ACTIVE,
                UserSubscription::STATUS_CANCELLED,
            ])
            ->whereNull('cancelled_at')
            ->orWhere('cancelled_at', '>', $startDate)
            ->count();

        // Subscriptions cancelled during period
        $cancelledDuringPeriod = UserSubscription::where('status', UserSubscription::STATUS_CANCELLED)
            ->whereBetween('cancelled_at', [$startDate, $endDate])
            ->count();

        $churnRate = $activeAtStart > 0
            ? round(($cancelledDuringPeriod / $activeAtStart) * 100, 2)
            : 0;

        return [
            'period' => [
                'start' => $startDate->toDateString(),
                'end' => $endDate->toDateString(),
            ],
            'active_at_start' => $activeAtStart,
            'cancelled_during_period' => $cancelledDuringPeriod,
            'churn_rate' => $churnRate,
        ];
    }

    /**
     * Get overage revenue.
     */
    public function getOverageRevenue(?Carbon $startDate = null, ?Carbon $endDate = null): array
    {
        $startDate = $startDate ?? Carbon::now()->startOfMonth();
        $endDate = $endDate ?? Carbon::now()->endOfMonth();

        $overageInvoices = Invoice::where('type', 'ppo_overage')
            ->where('status', 'paid')
            ->whereBetween('paid_at', [$startDate, $endDate])
            ->get();

        $totalRevenue = $overageInvoices->sum('total');
        $totalBags = $overageInvoices->sum(function ($invoice) {
            return $invoice->metadata['overage_bags'] ?? 0;
        });

        return [
            'period' => [
                'start' => $startDate->toDateString(),
                'end' => $endDate->toDateString(),
            ],
            'total_overage_revenue' => round($totalRevenue, 2),
            'total_overage_invoices' => $overageInvoices->count(),
            'total_overage_bags' => $totalBags,
            'avg_per_invoice' => $overageInvoices->count() > 0
                ? round($totalRevenue / $overageInvoices->count(), 2)
                : 0,
        ];
    }

    /**
     * Get monthly recurring revenue (MRR).
     */
    public function getMRR(): array
    {
        $activeSubscriptions = UserSubscription::where('status', UserSubscription::STATUS_ACTIVE)
            ->with('plan')
            ->get();

        $mrr = 0;
        foreach ($activeSubscriptions as $subscription) {
            $price = $subscription->plan->getPriceForCycle($subscription->billing_cycle);
            if ($price) {
                // Normalize to monthly
                $monthlyPrice = match ($subscription->billing_cycle) {
                    'daily' => $price * 30,
                    'weekly' => $price * 4,
                    'monthly' => $price,
                    'annual' => $price / 12,
                    default => $price,
                };
                $mrr += $monthlyPrice;
            }
        }

        return [
            'mrr' => round($mrr, 2),
            'arr' => round($mrr * 12, 2),
            'active_subscriptions' => $activeSubscriptions->count(),
            'avg_revenue_per_subscription' => $activeSubscriptions->count() > 0
                ? round($mrr / $activeSubscriptions->count(), 2)
                : 0,
        ];
    }

    /**
     * Get dashboard summary.
     */
    public function getDashboardSummary(): array
    {
        return [
            'mrr' => $this->getMRR(),
            'status_distribution' => $this->getStatusDistribution(),
            'churn_rate' => $this->getChurnRate(),
            'overage_revenue' => $this->getOverageRevenue(),
        ];
    }
}

FILE: app/Services/Subscription/SubscriptionOverageService.php
--------------------------------------------------------------------------------
<?php

namespace App\Services\Subscription;

use App\Models\User;
use App\Models\UserSubscription;
use App\Models\Invoice;
use App\Models\InvoiceLine;
use App\Models\Payment;
use App\Models\AuditLog;
use App\Services\Stripe\StripeService;
use Illuminate\Support\Facades\DB;
use Illuminate\Support\Facades\Log;
use Stripe\StripeClient;

class SubscriptionOverageService
{
    protected StripeService $stripeService;
    protected StripeClient $stripe;

    public function __construct(StripeService $stripeService)
    {
        $this->stripeService = $stripeService;
        $this->stripe = new StripeClient(config('stripe.secret'));
    }

    /**
     * Handle overage when user exceeds bag limit.
     * Creates PPO invoice and charges via Stripe.
     *
     * @param UserSubscription $subscription
     * @param int $overageBags Number of bags over the limit
     * @param string|null $description Optional description for invoice
     * @return array Invoice and payment intent details
     */
    public function handleOverage(
        UserSubscription $subscription,
        int $overageBags = 1,
        ?string $description = null
    ): array {
        if ($overageBags <= 0) {
            throw new \InvalidArgumentException('Overage bags must be positive');
        }

        $plan = $subscription->plan;

        if (!$plan->shouldChargePPOOnOverage()) {
            throw new \DomainException('Plan does not support PPO overage charges');
        }

        $pricePerBag = $plan->overage_price_per_bag;
        if (!$pricePerBag || $pricePerBag <= 0) {
            throw new \DomainException('Plan does not have overage price configured');
        }

        $totalAmount = $overageBags * $pricePerBag;
        $user = $subscription->user;

        return DB::transaction(function () use ($subscription, $user, $overageBags, $pricePerBag, $totalAmount, $description) {
            // Create PPO invoice
            $invoice = Invoice::create([
                'user_id' => $user->id,
                'subscription_id' => $subscription->id,
                'type' => 'ppo_overage',
                'status' => 'pending',
                'currency' => 'USD',
                'subtotal' => $totalAmount,
                'tax' => 0,
                'total' => $totalAmount,
                'issued_at' => now(),
                'due_at' => now(),
                'metadata' => [
                    'overage_bags' => $overageBags,
                    'price_per_bag' => $pricePerBag,
                    'subscription_id' => $subscription->id,
                    'plan_id' => $subscription->plan_id,
                ],
            ]);

            // Create invoice line
            InvoiceLine::create([
                'invoice_id' => $invoice->id,
                'type' => 'overage',
                'description' => $description ?? "Overage charge: {$overageBags} bag(s) @ \${$pricePerBag}/bag",
                'quantity' => $overageBags,
                'unit_price' => $pricePerBag,
                'amount' => $totalAmount,
            ]);

            // Create Stripe payment intent
            $stripeCustomerId = $this->stripeService->createOrGetCustomer($user);

            $paymentIntent = $this->stripe->paymentIntents->create([
                'amount' => (int) round($totalAmount * 100),
                'currency' => 'usd',
                'customer' => $stripeCustomerId,
                'description' => "Overage charge for {$overageBags} bag(s)",
                'metadata' => [
                    'invoice_id' => $invoice->id,
                    'user_id' => $user->id,
                    'subscription_id' => $subscription->id,
                    'type' => 'ppo_overage',
                    'overage_bags' => $overageBags,
                ],
                // Use default payment method if available
                'payment_method' => $this->getDefaultPaymentMethod($stripeCustomerId),
                'confirm' => true,
                'off_session' => true,
            ], [
                'idempotency_key' => "overage_{$invoice->id}_{$subscription->id}",
            ]);

            // Create payment record
            $payment = Payment::create([
                'invoice_id' => $invoice->id,
                'user_id' => $user->id,
                'stripe_payment_intent_id' => $paymentIntent->id,
                'amount' => $totalAmount,
                'currency' => 'USD',
                'status' => $this->mapPaymentStatus($paymentIntent->status),
                'payment_method' => 'card',
                'metadata' => [
                    'type' => 'ppo_overage',
                    'overage_bags' => $overageBags,
                ],
            ]);

            // Update invoice if payment succeeded
            if ($paymentIntent->status === 'succeeded') {
                $invoice->update([
                    'status' => 'paid',
                    'paid_at' => now(),
                ]);
                $payment->update(['status' => Payment::STATUS_SUCCEEDED]);
            }

            // Audit log
            AuditLog::create([
                'user_id' => $user->id,
                'action' => 'overage_charge_created',
                'entity_type' => 'invoice',
                'entity_id' => $invoice->id,
                'metadata' => [
                    'overage_bags' => $overageBags,
                    'amount' => $totalAmount,
                    'payment_intent_id' => $paymentIntent->id,
                    'payment_status' => $paymentIntent->status,
                    'subscription_id' => $subscription->id,
                ],
            ]);

            Log::info('Overage charge created', [
                'invoice_id' => $invoice->id,
                'subscription_id' => $subscription->id,
                'overage_bags' => $overageBags,
                'amount' => $totalAmount,
                'status' => $paymentIntent->status,
            ]);

            return [
                'invoice' => $invoice->fresh(),
                'payment' => $payment->fresh(),
                'payment_intent_id' => $paymentIntent->id,
                'payment_status' => $paymentIntent->status,
                'client_secret' => $paymentIntent->client_secret,
                'requires_action' => $paymentIntent->status === 'requires_action',
            ];
        });
    }

    /**
     * Check if overage charge is needed and process it.
     *
     * @param UserSubscription $subscription
     * @param int $bagsToUse Number of bags being used
     * @return array|null Returns charge details if overage occurred, null otherwise
     */
    public function checkAndChargeOverage(UserSubscription $subscription, int $bagsToUse = 1): ?array
    {
        $plan = $subscription->plan;

        // Check if plan supports PPO overage
        if (!$plan->shouldChargePPOOnOverage()) {
            return null;
        }

        // Calculate if this will cause overage
        $currentUsed = $subscription->bags_plan_used;
        $limit = $subscription->bags_plan_total;
        $newTotal = $currentUsed + $bagsToUse;

        if ($newTotal <= $limit) {
            // No overage
            return null;
        }

        // Calculate overage amount
        $overageBags = $newTotal - $limit;

        // Only charge for new overage, not existing
        if ($currentUsed >= $limit) {
            // Already over limit, charge for all new bags
            $overageBags = $bagsToUse;
        }

        try {
            return $this->handleOverage($subscription, $overageBags);
        } catch (\Exception $e) {
            Log::error('Failed to charge overage', [
                'subscription_id' => $subscription->id,
                'overage_bags' => $overageBags,
                'error' => $e->getMessage(),
            ]);
            throw $e;
        }
    }

    /**
     * Get default payment method for customer.
     */
    protected function getDefaultPaymentMethod(string $customerId): ?string
    {
        try {
            $customer = $this->stripe->customers->retrieve($customerId);
            return $customer->invoice_settings->default_payment_method
                ?? $customer->default_source
                ?? null;
        } catch (\Exception $e) {
            return null;
        }
    }

    /**
     * Map Stripe payment intent status to local status.
     */
    protected function mapPaymentStatus(string $stripeStatus): string
    {
        return match ($stripeStatus) {
            'succeeded' => Payment::STATUS_SUCCEEDED,
            'processing' => Payment::STATUS_PENDING,
            'requires_action', 'requires_payment_method' => Payment::STATUS_PENDING,
            'canceled' => Payment::STATUS_FAILED,
            default => Payment::STATUS_PENDING,
        };
    }
}

FILE: app/Services/Subscription/SubscriptionService.php
--------------------------------------------------------------------------------
<?php

namespace App\Services\Subscription;

use App\Models\User;
use App\Models\SubscriptionPlan;
use App\Models\UserSubscription;
use App\Models\AuditLog;
use App\Services\Stripe\StripeSubscriptionService;
use Illuminate\Support\Facades\DB;
use Illuminate\Support\Facades\Log;

class SubscriptionService
{
    protected StripeSubscriptionService $stripeSubscription;

    public function __construct(StripeSubscriptionService $stripeSubscription)
    {
        $this->stripeSubscription = $stripeSubscription;
    }

    /**
     * Create a new subscription with Stripe integration.
     * Returns local subscription + Stripe client_secret for payment confirmation.
     */
    public function create(
        User $user,
        SubscriptionPlan $plan,
        string $billingCycle
    ): array {
        // Validate billing cycle
        if (!in_array($billingCycle, SubscriptionPlan::CYCLES)) {
            throw new \InvalidArgumentException('Invalid billing cycle: ' . $billingCycle);
        }

        // Validate plan has price for this cycle
        $price = $plan->getPriceForCycle($billingCycle);
        if (!$price) {
            throw new \DomainException("Plan does not support {$billingCycle} billing cycle.");
        }

        // Validate plan is synced to Stripe
        if (!$plan->getStripePriceIdForCycle($billingCycle)) {
            throw new \DomainException("Plan is not synced to Stripe for {$billingCycle} cycle.");
        }

        // Prevent duplicate active subscriptions
        $existingActive = $user->subscriptions()
            ->whereIn('status', [
                UserSubscription::STATUS_PENDING,
                UserSubscription::STATUS_ACTIVE,
                UserSubscription::STATUS_PAUSED,
            ])
            ->exists();

        if ($existingActive) {
            throw new \DomainException('User already has an active or pending subscription.');
        }

        return DB::transaction(function () use ($user, $plan, $billingCycle) {
            // Calculate bag allocation
            $bagsForCycle = $plan->getBagsForCycle($billingCycle);

            // Create local subscription (pending)
            $subscription = UserSubscription::create([
                'user_id' => $user->id,
                'plan_id' => $plan->id,
                'status' => UserSubscription::STATUS_PENDING,
                'billing_cycle' => $billingCycle,
                'bags_plan_period' => $bagsForCycle,
                'bags_plan_total' => $bagsForCycle,
                'bags_plan_balance' => $bagsForCycle,
                'bags_plan_used' => 0,
                'bags_available' => $bagsForCycle,
            ]);

            // Create Stripe subscription
            $stripeData = $this->stripeSubscription->createSubscription(
                $user,
                $plan,
                $billingCycle
            );

            // Update local subscription with Stripe data
            $subscription->update([
                'stripe_subscription_id' => $stripeData['stripe_subscription_id'],
                'stripe_customer_id' => $stripeData['stripe_customer_id'],
                'current_period_start' => \Carbon\Carbon::createFromTimestamp($stripeData['current_period_start']),
                'current_period_end' => \Carbon\Carbon::createFromTimestamp($stripeData['current_period_end']),
            ]);

            // Audit log
            AuditLog::create([
                'user_id' => $user->id,
                'action' => 'subscription_created',
                'entity_type' => 'subscription',
                'entity_id' => $subscription->id,
                'metadata' => [
                    'plan_id' => $plan->id,
                    'plan_name' => $plan->name,
                    'billing_cycle' => $billingCycle,
                    'stripe_subscription_id' => $stripeData['stripe_subscription_id'],
                ],
            ]);

            Log::info('Created subscription', [
                'user_id' => $user->id,
                'subscription_id' => $subscription->id,
                'stripe_subscription_id' => $stripeData['stripe_subscription_id'],
            ]);

            return [
                'subscription' => $subscription->fresh()->load('plan'),
                'client_secret' => $stripeData['client_secret'],
                'stripe_subscription_id' => $stripeData['stripe_subscription_id'],
            ];
        });
    }

    /**
     * Cancel subscription at period end.
     */
    public function cancel(UserSubscription $subscription, ?string $reason = null): UserSubscription
    {
        if (!in_array($subscription->status, [
            UserSubscription::STATUS_ACTIVE,
            UserSubscription::STATUS_PAUSED,
            UserSubscription::STATUS_PENDING,
        ])) {
            throw new \DomainException('Subscription cannot be cancelled in its current state.');
        }

        return DB::transaction(function () use ($subscription, $reason) {
            // Cancel in Stripe (at period end)
            if ($subscription->stripe_subscription_id) {
                $stripeData = $this->stripeSubscription->cancelAtPeriodEnd($subscription, $reason);

                $subscription->update([
                    'cancel_at_period_end' => true,
                    'cancel_reason' => $reason,
                ]);
            } else {
                // No Stripe subscription, cancel immediately
                $subscription->update([
                    'status' => UserSubscription::STATUS_CANCELLED,
                    'cancelled_at' => now(),
                    'cancel_reason' => $reason,
                ]);

                // Remove from user
                if ($subscription->user->subscription_id === $subscription->id) {
                    $subscription->user->update(['subscription_id' => null]);
                }
            }

            // Audit log
            AuditLog::create([
                'user_id' => $subscription->user_id,
                'action' => 'subscription_cancel_requested',
                'entity_type' => 'subscription',
                'entity_id' => $subscription->id,
                'metadata' => [
                    'reason' => $reason,
                    'at_period_end' => $subscription->cancel_at_period_end,
                ],
            ]);

            return $subscription->fresh();
        });
    }

    /**
     * Reactivate a subscription that was scheduled for cancellation.
     */
    public function reactivate(UserSubscription $subscription): UserSubscription
    {
        if (!$subscription->cancel_at_period_end) {
            throw new \DomainException('Subscription is not scheduled for cancellation.');
        }

        if (!$subscription->isActive()) {
            throw new \DomainException('Only active subscriptions can be reactivated.');
        }

        return DB::transaction(function () use ($subscription) {
            if ($subscription->stripe_subscription_id) {
                $this->stripeSubscription->reactivate($subscription);
            }

            $subscription->update([
                'cancel_at_period_end' => false,
                'cancel_reason' => null,
            ]);

            // Audit log
            AuditLog::create([
                'user_id' => $subscription->user_id,
                'action' => 'subscription_reactivated',
                'entity_type' => 'subscription',
                'entity_id' => $subscription->id,
            ]);

            return $subscription->fresh();
        });
    }

    /**
     * Upgrade subscription to a new plan (immediate, with proration).
     */
    public function upgrade(
        UserSubscription $subscription,
        SubscriptionPlan $newPlan,
        ?string $newBillingCycle = null
    ): UserSubscription {
        if (!$subscription->isActive()) {
            throw new \DomainException('Only active subscriptions can be upgraded.');
        }

        $newCycle = $newBillingCycle ?? $subscription->billing_cycle;

        // Validate new plan has price for the cycle
        if (!$newPlan->getStripePriceIdForCycle($newCycle)) {
            throw new \DomainException("New plan does not support {$newCycle} billing cycle.");
        }

        // Ensure it's actually an upgrade
        $currentPrice = $subscription->plan->getPriceForCycle($subscription->billing_cycle);
        $newPrice = $newPlan->getPriceForCycle($newCycle);

        if ($newPrice <= $currentPrice) {
            throw new \DomainException('Use downgrade for reducing plan level.');
        }

        return DB::transaction(function () use ($subscription, $newPlan, $newCycle) {
            $oldPlan = $subscription->plan;

            // Update in Stripe with proration
            if ($subscription->stripe_subscription_id) {
                $this->stripeSubscription->updatePlan(
                    $subscription,
                    $newPlan,
                    $newCycle,
                    'create_prorations'
                );
            }

            // Update local subscription
            $bagsForCycle = $newPlan->getBagsForCycle($newCycle);

            $subscription->update([
                'plan_id' => $newPlan->id,
                'billing_cycle' => $newCycle,
                'bags_plan_total' => $bagsForCycle,
                'bags_plan_balance' => $bagsForCycle - $subscription->bags_plan_used,
                'bags_available' => $bagsForCycle - $subscription->bags_plan_used,
                'status' => UserSubscription::STATUS_UPGRADED,
            ]);

            // Immediately change to active
            $subscription->update(['status' => UserSubscription::STATUS_ACTIVE]);

            // Audit log
            AuditLog::create([
                'user_id' => $subscription->user_id,
                'action' => 'subscription_upgraded',
                'entity_type' => 'subscription',
                'entity_id' => $subscription->id,
                'metadata' => [
                    'old_plan_id' => $oldPlan->id,
                    'old_plan_name' => $oldPlan->name,
                    'new_plan_id' => $newPlan->id,
                    'new_plan_name' => $newPlan->name,
                    'billing_cycle' => $newCycle,
                ],
            ]);

            return $subscription->fresh()->load('plan');
        });
    }

    /**
     * Downgrade subscription (effective at end of period).
     */
    public function downgrade(
        UserSubscription $subscription,
        SubscriptionPlan $newPlan,
        ?string $newBillingCycle = null
    ): UserSubscription {
        if (!$subscription->isActive()) {
            throw new \DomainException('Only active subscriptions can be downgraded.');
        }

        $newCycle = $newBillingCycle ?? $subscription->billing_cycle;

        // Validate new plan
        if (!$newPlan->getStripePriceIdForCycle($newCycle)) {
            throw new \DomainException("New plan does not support {$newCycle} billing cycle.");
        }

        return DB::transaction(function () use ($subscription, $newPlan, $newCycle) {
            $scheduleId = null;

            // Schedule in Stripe (no immediate change)
            if ($subscription->stripe_subscription_id) {
                $scheduleData = $this->stripeSubscription->schedulePlanChange(
                    $subscription,
                    $newPlan,
                    $newCycle
                );
                $scheduleId = $scheduleData['schedule_id'] ?? null;
            }

            // Store pending plan change locally (including schedule ID)
            $subscription->update([
                'pending_plan_id' => $newPlan->id,
                'pending_billing_cycle' => $newCycle,
                'stripe_schedule_id' => $scheduleId,
            ]);

            // Audit log
            AuditLog::create([
                'user_id' => $subscription->user_id,
                'action' => 'subscription_downgrade_scheduled',
                'entity_type' => 'subscription',
                'entity_id' => $subscription->id,
                'metadata' => [
                    'current_plan_id' => $subscription->plan_id,
                    'new_plan_id' => $newPlan->id,
                    'new_plan_name' => $newPlan->name,
                    'effective_at' => $subscription->current_period_end?->toDateString(),
                ],
            ]);

            return $subscription->fresh();
        });
    }

    /**
     * Pause subscription billing.
     */
    public function pause(UserSubscription $subscription, ?string $reason = null): UserSubscription
    {
        if (!$subscription->isActive()) {
            throw new \DomainException('Only active subscriptions can be paused.');
        }

        return DB::transaction(function () use ($subscription, $reason) {
            // Pause in Stripe
            if ($subscription->stripe_subscription_id) {
                $this->stripeSubscription->pauseCollection($subscription);
            }

            $subscription->update([
                'status' => UserSubscription::STATUS_PAUSED,
                'notes' => $reason,
            ]);

            // Audit log
            AuditLog::create([
                'user_id' => $subscription->user_id,
                'action' => 'subscription_paused',
                'entity_type' => 'subscription',
                'entity_id' => $subscription->id,
                'metadata' => ['reason' => $reason],
            ]);

            Log::info('Subscription paused', ['subscription_id' => $subscription->id]);

            return $subscription->fresh();
        });
    }

    /**
     * Resume paused subscription billing.
     */
    public function resume(UserSubscription $subscription): UserSubscription
    {
        if ($subscription->status !== UserSubscription::STATUS_PAUSED) {
            throw new \DomainException('Only paused subscriptions can be resumed.');
        }

        return DB::transaction(function () use ($subscription) {
            // Resume in Stripe
            if ($subscription->stripe_subscription_id) {
                $this->stripeSubscription->resumeCollection($subscription);
            }

            $subscription->update([
                'status' => UserSubscription::STATUS_ACTIVE,
            ]);

            // Audit log
            AuditLog::create([
                'user_id' => $subscription->user_id,
                'action' => 'subscription_resumed',
                'entity_type' => 'subscription',
                'entity_id' => $subscription->id,
            ]);

            Log::info('Subscription resumed', ['subscription_id' => $subscription->id]);

            return $subscription->fresh();
        });
    }

    /**
     * Record bag usage with overage check.
     * If usage exceeds limit and plan allows PPO, triggers overage charge.
     *
     * @param UserSubscription $subscription
     * @param int $bags Number of bags to record
     * @param SubscriptionOverageService|null $overageService
     * @return array ['subscription' => UserSubscription, 'overage_charge' => array|null]
     */
    public function recordBagUsageWithOverageCheck(
        UserSubscription $subscription,
        int $bags = 1,
        ?SubscriptionOverageService $overageService = null
    ): array {
        if (!$subscription->isActive()) {
            throw new \DomainException('Can only record usage on active subscriptions.');
        }

        $overageCharge = null;

        // Check if this will cause overage and handle it
        if ($overageService && $subscription->plan->shouldChargePPOOnOverage()) {
            $overageCharge = $overageService->checkAndChargeOverage($subscription, $bags);
        }

        // Record the usage
        $subscription->increment('bags_plan_used', $bags);
        $subscription->decrement('bags_plan_balance', $bags);
        $subscription->decrement('bags_available', $bags);

        return [
            'subscription' => $subscription->fresh(),
            'overage_charge' => $overageCharge,
        ];
    }

    /**
     * Record bag usage.
     */
    public function recordBagUsage(UserSubscription $subscription, int $bags = 1): UserSubscription
    {
        if (!$subscription->isActive()) {
            throw new \DomainException('Can only record usage on active subscriptions.');
        }

        $subscription->increment('bags_plan_used', $bags);
        $subscription->decrement('bags_plan_balance', $bags);
        $subscription->decrement('bags_available', $bags);

        return $subscription->fresh();
    }

    /**
     * Get available bags for current period.
     */
    public function getAvailableBags(UserSubscription $subscription): int
    {
        if (!$subscription->isActive()) {
            return 0;
        }

        return max(0, $subscription->bags_plan_total - $subscription->bags_plan_used);
    }

    /**
     * Check if pickup can proceed based on subscription.
     *
     * @return array ['allowed' => bool, 'reason' => string|null, 'requires_ppo' => bool]
     */
    public function canProceedWithPickup(UserSubscription $subscription, int $bags = 1): array
    {
        if (!$subscription->isActive()) {
            return [
                'allowed' => false,
                'reason' => 'Subscription is not active',
                'requires_ppo' => false,
            ];
        }

        $plan = $subscription->plan;
        $availableBags = $this->getAvailableBags($subscription);

        if ($availableBags >= $bags) {
            // Has enough bags
            return [
                'allowed' => true,
                'reason' => null,
                'requires_ppo' => false,
            ];
        }

        // Over limit - check policy
        if ($plan->shouldChargePPOOnOverage()) {
            return [
                'allowed' => true,
                'reason' => 'Overage will be charged as PPO',
                'requires_ppo' => true,
                'overage_bags' => $bags - $availableBags,
                'overage_amount' => ($bags - $availableBags) * $plan->overage_price_per_bag,
            ];
        }

        if ($plan->shouldBlockOnOverage()) {
            return [
                'allowed' => false,
                'reason' => 'Bag limit exceeded. Please upgrade your plan.',
                'requires_ppo' => false,
            ];
        }

        return [
            'allowed' => false,
            'reason' => 'Unable to process pickup',
            'requires_ppo' => false,
        ];
    }
}

FILE: app/Services/Subscription/SubscriptionWebhookHandler.php
--------------------------------------------------------------------------------
<?php

namespace App\Services\Subscription;

use App\Models\Invoice;
use App\Models\InvoiceLine;
use App\Models\Payment;
use App\Models\UserSubscription;
use App\Models\SubscriptionPlan;
use App\Models\AuditLog;
use App\Services\Invoice\InvoiceService;
use Illuminate\Support\Facades\DB;
use Illuminate\Support\Facades\Log;

class SubscriptionWebhookHandler
{
    protected InvoiceService $invoiceService;

    public function __construct(InvoiceService $invoiceService)
    {
        $this->invoiceService = $invoiceService;
    }

    /**
     * Handle invoice.paid event.
     * This is triggered when a subscription invoice is successfully paid.
     */
    public function handleInvoicePaid(\Stripe\Invoice $stripeInvoice): void
    {
        // Skip non-subscription invoices
        if (!$stripeInvoice->subscription) {
            Log::info('Skipping non-subscription invoice', ['invoice_id' => $stripeInvoice->id]);
            return;
        }

        $subscription = UserSubscription::where('stripe_subscription_id', $stripeInvoice->subscription)->first();

        if (!$subscription) {
            Log::warning('Subscription not found for invoice.paid', [
                'stripe_subscription_id' => $stripeInvoice->subscription,
                'invoice_id' => $stripeInvoice->id,
            ]);
            return;
        }

        DB::transaction(function () use ($subscription, $stripeInvoice) {
            // Check if invoice already processed
            $existingInvoice = Invoice::where('stripe_invoice_id', $stripeInvoice->id)->first();
            if ($existingInvoice && $existingInvoice->status === 'paid') {
                Log::info('Invoice already processed', ['stripe_invoice_id' => $stripeInvoice->id]);
                return;
            }

            // Create or update local invoice
            $invoice = $this->createOrUpdateInvoice($subscription, $stripeInvoice, 'paid');

            // Update subscription status
            $isFirstPayment = $subscription->status === 'pending';

            $subscription->update([
                'status' => UserSubscription::STATUS_ACTIVE,
                'current_period_start' => \Carbon\Carbon::createFromTimestamp($stripeInvoice->period_start),
                'current_period_end' => \Carbon\Carbon::createFromTimestamp($stripeInvoice->period_end),
                'cancel_at_period_end' => false,
            ]);

            // Reset bag allocations on renewal
            if (!$isFirstPayment) {
                $this->resetBagAllocations($subscription);
            }

            // Apply pending plan change if exists
            if ($subscription->pending_plan_id) {
                $this->applyPendingPlanChange($subscription);
            }

            // Set subscription on user if not already set
            if ($subscription->user->subscription_id !== $subscription->id) {
                $subscription->user->update(['subscription_id' => $subscription->id]);
            }

            // Audit log
            AuditLog::create([
                'user_id' => $subscription->user_id,
                'action' => $isFirstPayment ? 'subscription_activated' : 'subscription_renewed',
                'entity_type' => 'subscription',
                'entity_id' => $subscription->id,
                'metadata' => [
                    'stripe_invoice_id' => $stripeInvoice->id,
                    'amount' => $stripeInvoice->amount_paid / 100,
                    'period_start' => date('Y-m-d', $stripeInvoice->period_start),
                    'period_end' => date('Y-m-d', $stripeInvoice->period_end),
                ],
            ]);

            Log::info('Processed invoice.paid for subscription', [
                'subscription_id' => $subscription->id,
                'invoice_id' => $invoice->id,
            ]);
        });
    }

    /**
     * Handle invoice.payment_failed event.
     */
    public function handleInvoicePaymentFailed(\Stripe\Invoice $stripeInvoice): void
    {
        if (!$stripeInvoice->subscription) {
            return;
        }

        $subscription = UserSubscription::where('stripe_subscription_id', $stripeInvoice->subscription)->first();

        if (!$subscription) {
            Log::warning('Subscription not found for invoice.payment_failed', [
                'stripe_subscription_id' => $stripeInvoice->subscription,
            ]);
            return;
        }

        DB::transaction(function () use ($subscription, $stripeInvoice) {
            // Create invoice record
            $this->createOrUpdateInvoice($subscription, $stripeInvoice, 'payment_failed');

            // Update subscription status
            $subscription->update([
                'status' => UserSubscription::STATUS_PAST_DUE,
            ]);

            // Audit log
            AuditLog::create([
                'user_id' => $subscription->user_id,
                'action' => 'subscription_payment_failed',
                'entity_type' => 'subscription',
                'entity_id' => $subscription->id,
                'metadata' => [
                    'stripe_invoice_id' => $stripeInvoice->id,
                    'amount' => $stripeInvoice->amount_due / 100,
                ],
            ]);

            Log::warning('Subscription payment failed', [
                'subscription_id' => $subscription->id,
                'stripe_invoice_id' => $stripeInvoice->id,
            ]);
        });
    }

    /**
     * Handle customer.subscription.updated event.
     */
    public function handleSubscriptionUpdated(\Stripe\Subscription $stripeSubscription): void
    {
        $subscription = UserSubscription::where('stripe_subscription_id', $stripeSubscription->id)->first();

        if (!$subscription) {
            Log::warning('Subscription not found for update', [
                'stripe_subscription_id' => $stripeSubscription->id,
            ]);
            return;
        }

        DB::transaction(function () use ($subscription, $stripeSubscription) {
            $updates = [
                'cancel_at_period_end' => $stripeSubscription->cancel_at_period_end,
                'current_period_start' => \Carbon\Carbon::createFromTimestamp($stripeSubscription->current_period_start),
                'current_period_end' => \Carbon\Carbon::createFromTimestamp($stripeSubscription->current_period_end),
            ];

            // Map Stripe status to local status
            $statusMap = [
                'active' => UserSubscription::STATUS_ACTIVE,
                'past_due' => UserSubscription::STATUS_PAST_DUE,
                'canceled' => UserSubscription::STATUS_CANCELLED,
                'paused' => UserSubscription::STATUS_PAUSED,
            ];

            if (isset($statusMap[$stripeSubscription->status])) {
                $updates['status'] = $statusMap[$stripeSubscription->status];
            }

            $subscription->update($updates);

            Log::info('Subscription updated from webhook', [
                'subscription_id' => $subscription->id,
                'stripe_status' => $stripeSubscription->status,
            ]);
        });
    }

    /**
     * Handle customer.subscription.deleted event.
     */
    public function handleSubscriptionDeleted(\Stripe\Subscription $stripeSubscription): void
    {
        $subscription = UserSubscription::where('stripe_subscription_id', $stripeSubscription->id)->first();

        if (!$subscription) {
            Log::warning('Subscription not found for deletion', [
                'stripe_subscription_id' => $stripeSubscription->id,
            ]);
            return;
        }

        DB::transaction(function () use ($subscription, $stripeSubscription) {
            $subscription->update([
                'status' => UserSubscription::STATUS_CANCELLED,
                'cancelled_at' => now(),
            ]);

            // Remove subscription from user
            if ($subscription->user->subscription_id === $subscription->id) {
                $subscription->user->update(['subscription_id' => null]);
            }

            // Audit log
            AuditLog::create([
                'user_id' => $subscription->user_id,
                'action' => 'subscription_cancelled',
                'entity_type' => 'subscription',
                'entity_id' => $subscription->id,
                'metadata' => [
                    'stripe_subscription_id' => $stripeSubscription->id,
                    'ended_at' => date('Y-m-d H:i:s'),
                ],
            ]);

            Log::info('Subscription cancelled', [
                'subscription_id' => $subscription->id,
            ]);
        });
    }

    /**
     * Create or update local invoice from Stripe invoice.
     */
    protected function createOrUpdateInvoice(
        UserSubscription $subscription,
        \Stripe\Invoice $stripeInvoice,
        string $status
    ): Invoice {
        $invoice = Invoice::where('stripe_invoice_id', $stripeInvoice->id)->first();

        if ($invoice) {
            $invoice->update([
                'status' => $status,
                'paid_at' => $status === 'paid' ? now() : null,
            ]);
            return $invoice;
        }

        // Create new invoice
        $invoice = Invoice::create([
            'stripe_invoice_id' => $stripeInvoice->id,
            'user_id' => $subscription->user_id,
            'subscription_id' => $subscription->id,
            'type' => 'subscription',
            'status' => $status,
            'currency' => strtoupper($stripeInvoice->currency),
            'subtotal' => $stripeInvoice->subtotal / 100,
            'tax' => $stripeInvoice->tax ? $stripeInvoice->tax / 100 : 0,
            'total' => $stripeInvoice->total / 100,
            'issued_at' => \Carbon\Carbon::createFromTimestamp($stripeInvoice->created),
            'paid_at' => $status === 'paid' ? now() : null,
            'metadata' => [
                'stripe_invoice_number' => $stripeInvoice->number,
                'billing_reason' => $stripeInvoice->billing_reason,
            ],
        ]);

        // Create invoice line items
        foreach ($stripeInvoice->lines->data as $line) {
            InvoiceLine::create([
                'invoice_id' => $invoice->id,
                'type' => 'subscription',
                'description' => $line->description ?? 'Subscription charge',
                'quantity' => $line->quantity ?? 1,
                'unit_price' => $line->unit_amount ? $line->unit_amount / 100 : $line->amount / 100,
                'amount' => $line->amount / 100,
            ]);
        }

        return $invoice;
    }

    /**
     * Reset bag allocations for new billing period.
     */
    protected function resetBagAllocations(UserSubscription $subscription): void
    {
        $plan = $subscription->plan;
        $bagsForCycle = $plan->getBagsForCycle($subscription->billing_cycle);

        $subscription->update([
            'bags_plan_total' => $bagsForCycle,
            'bags_plan_balance' => $bagsForCycle,
            'bags_plan_used' => 0,
            'bags_available' => $bagsForCycle,
        ]);
    }

    /**
     * Apply pending plan change after renewal.
     */
    protected function applyPendingPlanChange(UserSubscription $subscription): void
    {
        $newPlan = SubscriptionPlan::find($subscription->pending_plan_id);

        if (!$newPlan) {
            $subscription->update([
                'pending_plan_id' => null,
                'pending_billing_cycle' => null,
            ]);
            return;
        }

        $newCycle = $subscription->pending_billing_cycle ?? $subscription->billing_cycle;
        $bagsForCycle = $newPlan->getBagsForCycle($newCycle);

        $subscription->update([
            'plan_id' => $newPlan->id,
            'billing_cycle' => $newCycle,
            'bags_plan_total' => $bagsForCycle,
            'bags_plan_balance' => $bagsForCycle,
            'bags_plan_used' => 0,
            'bags_available' => $bagsForCycle,
            'pending_plan_id' => null,
            'pending_billing_cycle' => null,
            'stripe_schedule_id' => null, // Clear schedule after application
        ]);

        // Audit log
        AuditLog::create([
            'user_id' => $subscription->user_id,
            'action' => 'subscription_plan_changed',
            'entity_type' => 'subscription',
            'entity_id' => $subscription->id,
            'metadata' => [
                'new_plan_id' => $newPlan->id,
                'new_plan_name' => $newPlan->name,
                'billing_cycle' => $newCycle,
            ],
        ]);
    }

    /**
     * Handle invoice.finalized event.
     * Creates pending invoice record before payment is attempted.
     */
    public function handleInvoiceFinalized(\Stripe\Invoice $stripeInvoice): void
    {
        // Skip non-subscription invoices
        if (!$stripeInvoice->subscription) {
            Log::info('Skipping non-subscription invoice finalized', ['invoice_id' => $stripeInvoice->id]);
            return;
        }

        $subscription = UserSubscription::where('stripe_subscription_id', $stripeInvoice->subscription)->first();

        if (!$subscription) {
            Log::warning('Subscription not found for invoice.finalized', [
                'stripe_subscription_id' => $stripeInvoice->subscription,
                'invoice_id' => $stripeInvoice->id,
            ]);
            return;
        }

        // Check if invoice already exists
        $existingInvoice = Invoice::where('stripe_invoice_id', $stripeInvoice->id)->first();
        if ($existingInvoice) {
            Log::info('Invoice already exists for finalized event', ['stripe_invoice_id' => $stripeInvoice->id]);
            return;
        }

        // Create pending invoice
        $this->createOrUpdateInvoice($subscription, $stripeInvoice, 'pending_payment');

        Log::info('Created pending invoice from finalized event', [
            'stripe_invoice_id' => $stripeInvoice->id,
            'subscription_id' => $subscription->id,
        ]);
    }

    /**
     * Handle charge.refunded event for subscription invoices.
     * Updates subscription invoice status for partial/full refunds.
     */
    public function handleChargeRefunded(\Stripe\Charge $charge): void
    {
        // Get the invoice from payment intent
        $paymentIntentId = $charge->payment_intent;
        if (!$paymentIntentId) {
            return;
        }

        // Find subscription invoice that was paid with this charge
        $invoice = Invoice::where('type', 'subscription')
            ->whereHas('payments', function ($query) use ($paymentIntentId) {
                $query->where('stripe_payment_intent_id', $paymentIntentId);
            })
            ->first();

        if (!$invoice) {
            // Not a subscription invoice, PPO handler will deal with it
            return;
        }

        DB::transaction(function () use ($invoice, $charge) {
            $amountRefunded = $charge->amount_refunded / 100;
            $totalAmount = $charge->amount / 100;
            $isFullRefund = $amountRefunded >= $totalAmount;

            // Update invoice status
            $newStatus = $isFullRefund ? 'refunded' : 'partially_refunded';
            $invoice->update([
                'status' => $newStatus,
                'refunded_amount' => $amountRefunded,
            ]);

            // Log audit
            AuditLog::create([
                'user_id' => $invoice->user_id,
                'action' => $isFullRefund ? 'subscription_invoice_refunded' : 'subscription_invoice_partial_refund',
                'entity_type' => 'invoice',
                'entity_id' => $invoice->id,
                'metadata' => [
                    'charge_id' => $charge->id,
                    'amount_refunded' => $amountRefunded,
                    'total_amount' => $totalAmount,
                ],
            ]);

            Log::info('Processed subscription refund', [
                'invoice_id' => $invoice->id,
                'status' => $newStatus,
                'amount_refunded' => $amountRefunded,
            ]);
        });
    }
}

FILE: app/Services/Stripe/StripeProductService.php
--------------------------------------------------------------------------------
<?php

namespace App\Services\Stripe;

use App\Models\SubscriptionPlan;
use Stripe\StripeClient;
use Stripe\Exception\ApiErrorException;
use Illuminate\Support\Facades\Log;

class StripeProductService
{
    protected StripeClient $stripe;

    public function __construct()
    {
        $this->stripe = new StripeClient(config('stripe.secret'));
    }

    /**
     * Sync a plan to Stripe (create Product and Prices).
     */
    public function syncPlanToStripe(SubscriptionPlan $plan): SubscriptionPlan
    {
        // Create or update Product
        $productId = $this->syncProduct($plan);

        // Create Prices for each billing cycle
        $priceIds = $this->syncPrices($plan, $productId);

        // Update plan with Stripe IDs
        $plan->update(array_merge(
            ['stripe_product_id' => $productId],
            $priceIds
        ));

        Log::info('Plan synced to Stripe', [
            'plan_id' => $plan->id,
            'stripe_product_id' => $productId,
        ]);

        return $plan->fresh();
    }

    /**
     * Create or update Stripe Product.
     */
    protected function syncProduct(SubscriptionPlan $plan): string
    {
        try {
            if ($plan->stripe_product_id) {
                // Update existing product
                $this->stripe->products->update($plan->stripe_product_id, [
                    'name' => $plan->name,
                    'description' => $plan->description ?? "Subscription plan: {$plan->name}",
                    'metadata' => [
                        'plan_id' => $plan->id,
                        'slug' => $plan->slug,
                    ],
                ]);

                return $plan->stripe_product_id;
            }

            // Create new product
            $product = $this->stripe->products->create([
                'name' => $plan->name,
                'description' => $plan->description ?? "Subscription plan: {$plan->name}",
                'metadata' => [
                    'plan_id' => $plan->id,
                    'slug' => $plan->slug,
                ],
            ]);

            return $product->id;
        } catch (ApiErrorException $e) {
            Log::error('Failed to sync product to Stripe', [
                'plan_id' => $plan->id,
                'error' => $e->getMessage(),
            ]);
            throw new \RuntimeException('Failed to create Stripe product: ' . $e->getMessage());
        }
    }

    /**
     * Create Prices for each billing cycle.
     */
    protected function syncPrices(SubscriptionPlan $plan, string $productId): array
    {
        $priceIds = [];

        $cycleConfigs = [
            SubscriptionPlan::CYCLE_DAILY => [
                'field' => 'stripe_price_id_daily',
                'price' => $plan->price_daily,
                'interval' => 'day',
                'interval_count' => 1,
            ],
            SubscriptionPlan::CYCLE_WEEKLY => [
                'field' => 'stripe_price_id_weekly',
                'price' => $plan->price_weekly,
                'interval' => 'week',
                'interval_count' => 1,
            ],
            SubscriptionPlan::CYCLE_MONTHLY => [
                'field' => 'stripe_price_id_monthly',
                'price' => $plan->price_monthly,
                'interval' => 'month',
                'interval_count' => 1,
            ],
            SubscriptionPlan::CYCLE_ANNUAL => [
                'field' => 'stripe_price_id_annual',
                'price' => $plan->price_annual,
                'interval' => 'year',
                'interval_count' => 1,
            ],
        ];

        foreach ($cycleConfigs as $cycle => $config) {
            // Skip if no price set for this cycle
            if (empty($config['price'])) {
                continue;
            }

            $existingPriceId = $plan->{$config['field']};

            // If price exists and matches, skip
            if ($existingPriceId) {
                try {
                    $existingPrice = $this->stripe->prices->retrieve($existingPriceId);
                    $existingAmount = $existingPrice->unit_amount;
                    $newAmount = (int) round($config['price'] * 100);

                    // If amount matches, reuse the price
                    if ($existingAmount === $newAmount) {
                        $priceIds[$config['field']] = $existingPriceId;
                        continue;
                    }

                    // Archive old price (Stripe doesn't allow updating price amounts)
                    $this->stripe->prices->update($existingPriceId, ['active' => false]);
                } catch (ApiErrorException $e) {
                    // Price doesn't exist, will create new one
                }
            }

            // Create new price
            try {
                $price = $this->stripe->prices->create([
                    'product' => $productId,
                    'unit_amount' => (int) round($config['price'] * 100),
                    'currency' => strtolower(config('stripe.currency', 'usd')),
                    'recurring' => [
                        'interval' => $config['interval'],
                        'interval_count' => $config['interval_count'],
                    ],
                    'metadata' => [
                        'plan_id' => $plan->id,
                        'billing_cycle' => $cycle,
                    ],
                ]);

                $priceIds[$config['field']] = $price->id;

                Log::info('Created Stripe price', [
                    'plan_id' => $plan->id,
                    'cycle' => $cycle,
                    'price_id' => $price->id,
                ]);
            } catch (ApiErrorException $e) {
                Log::error('Failed to create Stripe price', [
                    'plan_id' => $plan->id,
                    'cycle' => $cycle,
                    'error' => $e->getMessage(),
                ]);
                throw new \RuntimeException("Failed to create Stripe price for {$cycle}: " . $e->getMessage());
            }
        }

        return $priceIds;
    }

    /**
     * Sync all active plans to Stripe.
     */
    public function syncAllPlansToStripe(): array
    {
        $plans = SubscriptionPlan::where('is_active', true)->get();
        $results = [];

        foreach ($plans as $plan) {
            try {
                $this->syncPlanToStripe($plan);
                $results[$plan->id] = ['status' => 'success', 'plan' => $plan->name];
            } catch (\Exception $e) {
                $results[$plan->id] = ['status' => 'error', 'plan' => $plan->name, 'error' => $e->getMessage()];
            }
        }

        return $results;
    }

    /**
     * Archive a plan in Stripe (deactivate product).
     */
    public function archivePlan(SubscriptionPlan $plan): bool
    {
        if (!$plan->stripe_product_id) {
            return true;
        }

        try {
            $this->stripe->products->update($plan->stripe_product_id, [
                'active' => false,
            ]);

            Log::info('Archived Stripe product', ['plan_id' => $plan->id]);
            return true;
        } catch (ApiErrorException $e) {
            Log::error('Failed to archive Stripe product', [
                'plan_id' => $plan->id,
                'error' => $e->getMessage(),
            ]);
            return false;
        }
    }
}

FILE: app/Services/Stripe/StripeService.php
--------------------------------------------------------------------------------
<?php

namespace App\Services\Stripe;

use App\Models\User;
use App\Models\Invoice;
use App\Models\Payment;
use App\Models\StripeCustomer;
use Stripe\StripeClient;
use Stripe\Exception\ApiErrorException;

class StripeService
{
    protected StripeClient $stripe;

    public function __construct()
    {
        $this->stripe = new StripeClient(config('stripe.secret'));
    }

    /**
     * Create or retrieve existing Stripe customer for user.
     */
    public function createOrGetCustomer(User $user): string
    {
        // Check if user already has a Stripe customer
        $existing = StripeCustomer::where('user_id', $user->id)->first();

        if ($existing) {
            return $existing->stripe_customer_id;
        }

        // Create new Stripe customer
        try {
            $customer = $this->stripe->customers->create([
                'email' => $user->email,
                'name' => $user->first_name . ' ' . $user->last_name,
                'metadata' => [
                    'user_id' => $user->id,
                ],
            ]);

            // Store the mapping
            StripeCustomer::create([
                'user_id' => $user->id,
                'stripe_customer_id' => $customer->id,
            ]);

            return $customer->id;
        } catch (ApiErrorException $e) {
            throw new \RuntimeException('Failed to create Stripe customer: ' . $e->getMessage());
        }
    }

    /**
     * Create a Payment Intent for an invoice.
     */
    public function createPaymentIntent(Invoice $invoice, User $user): array
    {
        // Ensure customer exists
        $customerId = $this->createOrGetCustomer($user);

        // Amount in cents
        $amountCents = (int) round($invoice->total * 100);

        if ($amountCents < 50) {
            throw new \InvalidArgumentException('Payment amount must be at least $0.50');
        }

        try {
            $idempotencyKey = "ppo_intent_invoice_{$invoice->id}";

            $paymentIntent = $this->stripe->paymentIntents->create([
                'amount' => $amountCents,
                'currency' => strtolower($invoice->currency ?? config('stripe.currency')),
                'customer' => $customerId,
                'metadata' => [
                    'invoice_id' => $invoice->id,
                    'user_id' => $user->id,
                    'invoice_type' => $invoice->type,
                ],
                'automatic_payment_methods' => [
                    'enabled' => true,
                ],
            ], [
                'idempotency_key' => $idempotencyKey,
            ]);

            return [
                'payment_intent_id' => $paymentIntent->id,
                'client_secret' => $paymentIntent->client_secret,
                'amount' => $invoice->total,
                'currency' => $invoice->currency ?? 'USD',
            ];
        } catch (ApiErrorException $e) {
            throw new \RuntimeException('Failed to create payment intent: ' . $e->getMessage());
        }
    }

    /**
     * Retrieve a Payment Intent by ID.
     */
    public function getPaymentIntent(string $paymentIntentId): \Stripe\PaymentIntent
    {
        try {
            return $this->stripe->paymentIntents->retrieve($paymentIntentId);
        } catch (ApiErrorException $e) {
            throw new \RuntimeException('Failed to retrieve payment intent: ' . $e->getMessage());
        }
    }

    /**
     * Issue a refund for a payment.
     */
    public function refundPayment(Payment $payment, ?int $amountCents = null): \Stripe\Refund
    {
        if (!$payment->stripe_payment_intent_id) {
            throw new \InvalidArgumentException('Payment has no Stripe payment intent');
        }

        try {
            $params = [
                'payment_intent' => $payment->stripe_payment_intent_id,
            ];

            // Partial refund if amount specified
            if ($amountCents !== null) {
                $params['amount'] = $amountCents;
            }

            $idempotencyKey = "refund_payment_{$payment->id}_" . ($amountCents ?? 'full');

            return $this->stripe->refunds->create($params, [
                'idempotency_key' => $idempotencyKey,
            ]);
        } catch (ApiErrorException $e) {
            throw new \RuntimeException('Failed to process refund: ' . $e->getMessage());
        }
    }

    /**
     * Verify webhook signature.
     */
    public function constructWebhookEvent(string $payload, string $signature): \Stripe\Event
    {
        $webhookSecret = config('stripe.webhook_secret');

        if (!$webhookSecret) {
            throw new \RuntimeException('Stripe webhook secret not configured');
        }

        try {
            return \Stripe\Webhook::constructEvent(
                $payload,
                $signature,
                $webhookSecret
            );
        } catch (\Stripe\Exception\SignatureVerificationException $e) {
            throw new \RuntimeException('Invalid webhook signature');
        }
    }
}

FILE: app/Services/Stripe/StripeSubscriptionService.php
--------------------------------------------------------------------------------
<?php

namespace App\Services\Stripe;

use App\Models\User;
use App\Models\Invoice;
use App\Models\UserSubscription;
use App\Models\SubscriptionPlan;
use App\Models\AuditLog;
use Stripe\StripeClient;
use Stripe\Exception\ApiErrorException;
use Illuminate\Support\Facades\DB;
use Illuminate\Support\Facades\Log;

class StripeSubscriptionService
{
    protected StripeClient $stripe;
    protected StripeService $stripeService;

    public function __construct(StripeService $stripeService)
    {
        $this->stripe = new StripeClient(config('stripe.secret'));
        $this->stripeService = $stripeService;
    }

    /**
     * Create a Stripe Subscription for a user.
     */
    public function createSubscription(
        User $user,
        SubscriptionPlan $plan,
        string $billingCycle,
        bool $startImmediately = true
    ): array {
        // Validate plan has Stripe price for this cycle
        $stripePriceId = $plan->getStripePriceIdForCycle($billingCycle);

        if (!$stripePriceId) {
            throw new \DomainException("Plan does not have a Stripe price for {$billingCycle} billing cycle.");
        }

        // Ensure customer exists in Stripe
        $stripeCustomerId = $this->stripeService->createOrGetCustomer($user);

        try {
            $subscriptionParams = [
                'customer' => $stripeCustomerId,
                'items' => [
                    ['price' => $stripePriceId],
                ],
                'metadata' => [
                    'user_id' => $user->id,
                    'plan_id' => $plan->id,
                    'billing_cycle' => $billingCycle,
                ],
                'payment_behavior' => 'default_incomplete', // Require payment confirmation
                'payment_settings' => [
                    'save_default_payment_method' => 'on_subscription',
                ],
                'expand' => ['latest_invoice.payment_intent'],
            ];

            // Apply proration for immediate start
            if ($startImmediately) {
                $subscriptionParams['proration_behavior'] = 'create_prorations';
            }

            $stripeSubscription = $this->stripe->subscriptions->create($subscriptionParams, [
                'idempotency_key' => "sub_create_{$user->id}_{$plan->id}_{$billingCycle}_" . date('YmdH'),
            ]);

            Log::info('Created Stripe subscription', [
                'user_id' => $user->id,
                'stripe_subscription_id' => $stripeSubscription->id,
                'status' => $stripeSubscription->status,
            ]);

            return [
                'stripe_subscription_id' => $stripeSubscription->id,
                'stripe_customer_id' => $stripeCustomerId,
                'status' => $stripeSubscription->status,
                'current_period_start' => $stripeSubscription->current_period_start,
                'current_period_end' => $stripeSubscription->current_period_end,
                'client_secret' => $stripeSubscription->latest_invoice?->payment_intent?->client_secret,
                'latest_invoice_id' => $stripeSubscription->latest_invoice?->id,
            ];
        } catch (ApiErrorException $e) {
            Log::error('Failed to create Stripe subscription', [
                'user_id' => $user->id,
                'plan_id' => $plan->id,
                'error' => $e->getMessage(),
            ]);
            throw new \RuntimeException('Failed to create subscription: ' . $e->getMessage());
        }
    }

    /**
     * Cancel a subscription at period end.
     */
    public function cancelAtPeriodEnd(UserSubscription $subscription, ?string $reason = null): array
    {
        if (!$subscription->stripe_subscription_id) {
            throw new \DomainException('Subscription is not linked to Stripe.');
        }

        try {
            $stripeSubscription = $this->stripe->subscriptions->update(
                $subscription->stripe_subscription_id,
                ['cancel_at_period_end' => true]
            );

            Log::info('Set subscription to cancel at period end', [
                'subscription_id' => $subscription->id,
                'stripe_subscription_id' => $subscription->stripe_subscription_id,
            ]);

            return [
                'cancel_at_period_end' => $stripeSubscription->cancel_at_period_end,
                'cancel_at' => $stripeSubscription->cancel_at,
                'current_period_end' => $stripeSubscription->current_period_end,
            ];
        } catch (ApiErrorException $e) {
            Log::error('Failed to cancel Stripe subscription', [
                'subscription_id' => $subscription->id,
                'error' => $e->getMessage(),
            ]);
            throw new \RuntimeException('Failed to cancel subscription: ' . $e->getMessage());
        }
    }

    /**
     * Cancel subscription immediately.
     */
    public function cancelImmediately(UserSubscription $subscription): bool
    {
        if (!$subscription->stripe_subscription_id) {
            throw new \DomainException('Subscription is not linked to Stripe.');
        }

        try {
            $this->stripe->subscriptions->cancel($subscription->stripe_subscription_id);

            Log::info('Cancelled subscription immediately', [
                'subscription_id' => $subscription->id,
                'stripe_subscription_id' => $subscription->stripe_subscription_id,
            ]);

            return true;
        } catch (ApiErrorException $e) {
            Log::error('Failed to cancel Stripe subscription immediately', [
                'subscription_id' => $subscription->id,
                'error' => $e->getMessage(),
            ]);
            throw new \RuntimeException('Failed to cancel subscription: ' . $e->getMessage());
        }
    }

    /**
     * Reactivate a subscription (remove cancel_at_period_end).
     */
    public function reactivate(UserSubscription $subscription): array
    {
        if (!$subscription->stripe_subscription_id) {
            throw new \DomainException('Subscription is not linked to Stripe.');
        }

        try {
            $stripeSubscription = $this->stripe->subscriptions->update(
                $subscription->stripe_subscription_id,
                ['cancel_at_period_end' => false]
            );

            Log::info('Reactivated subscription', [
                'subscription_id' => $subscription->id,
            ]);

            return [
                'cancel_at_period_end' => $stripeSubscription->cancel_at_period_end,
                'status' => $stripeSubscription->status,
            ];
        } catch (ApiErrorException $e) {
            Log::error('Failed to reactivate Stripe subscription', [
                'subscription_id' => $subscription->id,
                'error' => $e->getMessage(),
            ]);
            throw new \RuntimeException('Failed to reactivate subscription: ' . $e->getMessage());
        }
    }

    /**
     * Update subscription to a new plan (upgrade/downgrade).
     */
    public function updatePlan(
        UserSubscription $subscription,
        SubscriptionPlan $newPlan,
        string $newBillingCycle,
        string $prorationBehavior = 'create_prorations' // or 'none' for no proration
    ): array {
        if (!$subscription->stripe_subscription_id) {
            throw new \DomainException('Subscription is not linked to Stripe.');
        }

        $newPriceId = $newPlan->getStripePriceIdForCycle($newBillingCycle);

        if (!$newPriceId) {
            throw new \DomainException("New plan does not have a Stripe price for {$newBillingCycle} billing cycle.");
        }

        try {
            // Get current subscription to find the item ID
            $stripeSubscription = $this->stripe->subscriptions->retrieve($subscription->stripe_subscription_id);
            $itemId = $stripeSubscription->items->data[0]->id;

            // Update the subscription
            $idempotencyKey = "sub_upgrade_{$subscription->id}_{$newPlan->id}";

            $updatedSubscription = $this->stripe->subscriptions->update(
                $subscription->stripe_subscription_id,
                [
                    'items' => [
                        [
                            'id' => $itemId,
                            'price' => $newPriceId,
                        ],
                    ],
                    'proration_behavior' => $prorationBehavior,
                    'metadata' => [
                        'plan_id' => $newPlan->id,
                        'billing_cycle' => $newBillingCycle,
                    ],
                ],
                ['idempotency_key' => $idempotencyKey]
            );

            Log::info('Updated subscription plan', [
                'subscription_id' => $subscription->id,
                'old_plan_id' => $subscription->plan_id,
                'new_plan_id' => $newPlan->id,
                'proration_behavior' => $prorationBehavior,
            ]);

            return [
                'status' => $updatedSubscription->status,
                'current_period_start' => $updatedSubscription->current_period_start,
                'current_period_end' => $updatedSubscription->current_period_end,
                'latest_invoice_id' => $updatedSubscription->latest_invoice,
            ];
        } catch (ApiErrorException $e) {
            Log::error('Failed to update Stripe subscription plan', [
                'subscription_id' => $subscription->id,
                'new_plan_id' => $newPlan->id,
                'error' => $e->getMessage(),
            ]);
            throw new \RuntimeException('Failed to update subscription: ' . $e->getMessage());
        }
    }

    /**
     * Schedule plan change for end of period (for downgrades).
     */
    public function schedulePlanChange(
        UserSubscription $subscription,
        SubscriptionPlan $newPlan,
        string $newBillingCycle
    ): array {
        if (!$subscription->stripe_subscription_id) {
            throw new \DomainException('Subscription is not linked to Stripe.');
        }

        $newPriceId = $newPlan->getStripePriceIdForCycle($newBillingCycle);

        if (!$newPriceId) {
            throw new \DomainException("New plan does not have a Stripe price for {$newBillingCycle} billing cycle.");
        }

        try {
            // Get current subscription
            $stripeSubscription = $this->stripe->subscriptions->retrieve($subscription->stripe_subscription_id);
            $itemId = $stripeSubscription->items->data[0]->id;

            // Create a schedule to change at billing period end
            $idempotencyKey = "sub_downgrade_{$subscription->id}_{$newPlan->id}";

            $schedule = $this->stripe->subscriptionSchedules->create([
                'from_subscription' => $subscription->stripe_subscription_id,
            ], [
                'idempotency_key' => $idempotencyKey,
            ]);

            // Update the schedule with new phase
            $this->stripe->subscriptionSchedules->update($schedule->id, [
                'phases' => [
                    [
                        'items' => [
                            ['price' => $stripeSubscription->items->data[0]->price->id],
                        ],
                        'end_date' => $stripeSubscription->current_period_end,
                    ],
                    [
                        'items' => [
                            ['price' => $newPriceId],
                        ],
                    ],
                ],
            ]);

            Log::info('Scheduled plan change for end of period', [
                'subscription_id' => $subscription->id,
                'new_plan_id' => $newPlan->id,
                'effective_date' => date('Y-m-d', $stripeSubscription->current_period_end),
            ]);

            return [
                'schedule_id' => $schedule->id,
                'effective_date' => $stripeSubscription->current_period_end,
            ];
        } catch (ApiErrorException $e) {
            Log::error('Failed to schedule plan change', [
                'subscription_id' => $subscription->id,
                'error' => $e->getMessage(),
            ]);
            throw new \RuntimeException('Failed to schedule plan change: ' . $e->getMessage());
        }
    }

    /**
     * Pause subscription payment collection.
     */
    public function pauseCollection(UserSubscription $subscription): bool
    {
        if (!$subscription->stripe_subscription_id) {
            throw new \DomainException('Subscription is not linked to Stripe.');
        }

        try {
            $this->stripe->subscriptions->update($subscription->stripe_subscription_id, [
                'pause_collection' => [
                    'behavior' => 'mark_uncollectible',
                ],
            ]);

            Log::info('Paused subscription collection', [
                'subscription_id' => $subscription->id,
            ]);

            return true;
        } catch (ApiErrorException $e) {
            Log::error('Failed to pause subscription', [
                'subscription_id' => $subscription->id,
                'error' => $e->getMessage(),
            ]);
            throw new \RuntimeException('Failed to pause subscription: ' . $e->getMessage());
        }
    }

    /**
     * Resume subscription payment collection.
     */
    public function resumeCollection(UserSubscription $subscription): bool
    {
        if (!$subscription->stripe_subscription_id) {
            throw new \DomainException('Subscription is not linked to Stripe.');
        }

        try {
            $this->stripe->subscriptions->update($subscription->stripe_subscription_id, [
                'pause_collection' => '',
            ]);

            Log::info('Resumed subscription collection', [
                'subscription_id' => $subscription->id,
            ]);

            return true;
        } catch (ApiErrorException $e) {
            Log::error('Failed to resume subscription', [
                'subscription_id' => $subscription->id,
                'error' => $e->getMessage(),
            ]);
            throw new \RuntimeException('Failed to resume subscription: ' . $e->getMessage());
        }
    }

    /**
     * Retrieve subscription from Stripe.
     */
    public function retrieveSubscription(string $stripeSubscriptionId): \Stripe\Subscription
    {
        try {
            return $this->stripe->subscriptions->retrieve($stripeSubscriptionId);
        } catch (ApiErrorException $e) {
            throw new \RuntimeException('Failed to retrieve subscription: ' . $e->getMessage());
        }
    }

    /**
     * Get upcoming invoice for a subscription.
     */
    public function getUpcomingInvoice(UserSubscription $subscription): ?\Stripe\Invoice
    {
        if (!$subscription->stripe_subscription_id || !$subscription->stripe_customer_id) {
            return null;
        }

        try {
            /** @noinspection PhpUndefinedMethodInspection - Stripe SDK uses magic methods */
            return $this->stripe->invoices->upcoming([
                'customer' => $subscription->stripe_customer_id,
                'subscription' => $subscription->stripe_subscription_id,
            ]);
        } catch (ApiErrorException $e) {
            Log::warning('Could not retrieve upcoming invoice', [
                'subscription_id' => $subscription->id,
                'error' => $e->getMessage(),
            ]);
            return null;
        }
    }
}

FILE: app/Services/Payment/PaymentService.php
--------------------------------------------------------------------------------
<?php

namespace App\Services\Payment;

use App\Models\Invoice;
use App\Models\Payment;
use App\Models\User;
use App\Models\AuditLog;
use App\Services\Stripe\StripeService;
use App\Services\Invoice\InvoiceService;
use Illuminate\Support\Facades\DB;
use Illuminate\Support\Facades\Log;

class PaymentService
{
    protected StripeService $stripe;
    protected InvoiceService $invoices;

    public function __construct(StripeService $stripe, InvoiceService $invoices)
    {
        $this->stripe = $stripe;
        $this->invoices = $invoices;
    }

    /**
     * Create a payment intent for an invoice.
     * Returns client_secret for frontend.
     */
    public function createPaymentIntent(Invoice $invoice, User $user): array
    {
        // GUARD 1: Invoice already paid
        if ($invoice->isPaid()) {
            throw new \DomainException('Invoice already paid.');
        }

        // GUARD 2: Invoice already refunded
        if ($invoice->isRefunded()) {
            throw new \DomainException('Invoice has been refunded.');
        }

        // Validate invoice state
        if (!in_array($invoice->status, ['draft', 'pending_payment', 'payment_failed'])) {
            throw new \DomainException('Invoice is not payable. Current status: ' . $invoice->status);
        }

        // GUARD 3: Check for existing active payment (pending or succeeded)
        $existingPayment = Payment::where('invoice_id', $invoice->id)
            ->whereIn('status', [Payment::STATUS_PENDING, Payment::STATUS_SUCCEEDED])
            ->first();

        if ($existingPayment) {
            if ($existingPayment->status === Payment::STATUS_SUCCEEDED) {
                throw new \DomainException('Payment already completed for this invoice.');
            }

            // Return existing pending payment intent
            if ($existingPayment->stripe_payment_intent_id) {
                $intent = $this->stripe->getPaymentIntent($existingPayment->stripe_payment_intent_id);
                return [
                    'payment_intent_id' => $intent->id,
                    'client_secret' => $intent->client_secret,
                    'amount' => $invoice->total,
                    'currency' => $invoice->currency ?? 'USD',
                    'payment_id' => $existingPayment->id,
                    'existing' => true,
                ];
            }
        }

        return DB::transaction(function () use ($invoice, $user) {
            // Mark invoice as pending payment
            if ($invoice->status === 'draft') {
                $this->invoices->markPendingPayment($invoice);
            }

            // Create Stripe payment intent
            $intentData = $this->stripe->createPaymentIntent($invoice, $user);

            // Create payment record
            $payment = Payment::create([
                'invoice_id' => $invoice->id,
                'user_id' => $user->id,
                'amount' => $invoice->total,
                'currency' => $invoice->currency ?? 'USD',
                'status' => Payment::STATUS_PENDING,
                'stripe_payment_intent_id' => $intentData['payment_intent_id'],
            ]);

            return array_merge($intentData, [
                'payment_id' => $payment->id,
            ]);
        });
    }

    /**
     * Handle successful payment (from webhook).
     */
    public function markPaymentSucceeded(string $paymentIntentId): void
    {
        $payment = Payment::where('stripe_payment_intent_id', $paymentIntentId)->first();

        if (!$payment) {
            Log::warning('Payment not found for intent: ' . $paymentIntentId);
            return;
        }

        // Idempotency: skip if already succeeded
        if ($payment->isSucceeded()) {
            Log::info('Payment already succeeded: ' . $paymentIntentId);
            return;
        }

        DB::transaction(function () use ($payment) {
            // Update payment
            $payment->update([
                'status' => Payment::STATUS_SUCCEEDED,
                'paid_at' => now(),
            ]);

            // Update invoice
            $invoice = $payment->invoice;
            if ($invoice && $invoice->status !== 'paid') {
                $this->invoices->markPaid($invoice, [
                    'payment_id' => $payment->id,
                    'stripe_payment_intent_id' => $payment->stripe_payment_intent_id,
                ]);
            }

            // Audit log for payment success
            AuditLog::create([
                'user_id' => $payment->user_id,
                'action' => 'payment_succeeded',
                'entity_type' => 'payment',
                'entity_id' => $payment->id,
                'metadata' => [
                    'invoice_id' => $payment->invoice_id,
                    'amount' => $payment->amount,
                    'stripe_payment_intent_id' => $payment->stripe_payment_intent_id,
                ],
            ]);

            Log::info('Payment succeeded: ' . $payment->stripe_payment_intent_id);
        });
    }

    /**
     * Handle failed payment (from webhook).
     */
    public function markPaymentFailed(string $paymentIntentId, ?string $reason = null): void
    {
        $payment = Payment::where('stripe_payment_intent_id', $paymentIntentId)->first();

        if (!$payment) {
            Log::warning('Payment not found for intent: ' . $paymentIntentId);
            return;
        }

        // Idempotency: skip if already failed
        if ($payment->status === Payment::STATUS_FAILED) {
            Log::info('Payment already marked as failed: ' . $paymentIntentId);
            return;
        }

        DB::transaction(function () use ($payment, $reason) {
            // Update payment
            $payment->update([
                'status' => Payment::STATUS_FAILED,
                'failure_reason' => $reason,
            ]);

            // Update invoice
            $invoice = $payment->invoice;
            if ($invoice && $invoice->status === 'pending_payment') {
                $this->invoices->markPaymentFailed($invoice, $reason);
            }

            // Audit log for payment failure
            AuditLog::create([
                'user_id' => $payment->user_id,
                'action' => 'payment_failed',
                'entity_type' => 'payment',
                'entity_id' => $payment->id,
                'metadata' => [
                    'invoice_id' => $payment->invoice_id,
                    'amount' => $payment->amount,
                    'failure_reason' => $reason,
                    'stripe_payment_intent_id' => $payment->stripe_payment_intent_id,
                ],
            ]);

            Log::info('Payment failed: ' . $payment->stripe_payment_intent_id . ' - ' . $reason);
        });
    }

    /**
     * Get payment by invoice ID.
     */
    public function getPaymentByInvoice(int $invoiceId): ?Payment
    {
        return Payment::where('invoice_id', $invoiceId)
            ->orderBy('created_at', 'desc')
            ->first();
    }
}

FILE: app/Services/Payment/RefundService.php
--------------------------------------------------------------------------------
<?php

namespace App\Services\Payment;

use App\Models\Invoice;
use App\Models\Payment;
use App\Models\User;
use App\Models\AuditLog;
use App\Services\Stripe\StripeService;
use App\Services\Invoice\InvoiceService;
use Illuminate\Support\Facades\DB;
use Illuminate\Support\Facades\Log;

class RefundService
{
    protected StripeService $stripe;
    protected InvoiceService $invoices;

    public function __construct(StripeService $stripe, InvoiceService $invoices)
    {
        $this->stripe = $stripe;
        $this->invoices = $invoices;
    }

    /**
     * Process refund for an invoice (admin-triggered).
     */
    public function processRefund(Invoice $invoice, string $reason, ?User $admin = null): Payment
    {
        // Find successful payment
        $payment = Payment::where('invoice_id', $invoice->id)
            ->where('status', Payment::STATUS_SUCCEEDED)
            ->first();

        if (!$payment) {
            throw new \DomainException('No successful payment found for this invoice');
        }

        if (!$payment->stripe_payment_intent_id) {
            throw new \DomainException('Payment has no Stripe payment intent');
        }

        // Guard: Prevent double refund
        if ($payment->isRefunded()) {
            throw new \DomainException('Payment has already been refunded');
        }

        return DB::transaction(function () use ($invoice, $payment, $reason, $admin) {
            // Issue Stripe refund
            $refund = $this->stripe->refundPayment($payment);

            // Update payment
            $payment->update([
                'status' => Payment::STATUS_REFUNDED,
                'stripe_refund_id' => $refund->id,
                'refunded_at' => now(),
            ]);

            // Update invoice
            $this->invoices->markRefunded($invoice, $reason);

            // Create audit log
            AuditLog::create([
                'user_id' => $admin?->id,
                'action' => 'invoice_refund',
                'entity_type' => 'invoice',
                'entity_id' => $invoice->id,
                'metadata' => [
                    'reason' => $reason,
                    'payment_id' => $payment->id,
                    'stripe_refund_id' => $refund->id,
                    'amount' => $payment->amount,
                ],
            ]);

            Log::info('Refund processed: ' . $refund->id . ' for invoice: ' . $invoice->id);

            return $payment->fresh();
        });
    }

    /**
     * Process partial refund for an invoice.
     */
    public function processPartialRefund(Invoice $invoice, float $amountToRefund, string $reason, ?User $admin = null): Payment
    {
        $payment = Payment::where('invoice_id', $invoice->id)
            ->where('status', Payment::STATUS_SUCCEEDED)
            ->first();

        if (!$payment) {
            throw new \DomainException('No successful payment found for this invoice');
        }

        if ($amountToRefund > $payment->amount) {
            throw new \DomainException('Refund amount exceeds payment amount');
        }

        $amountCents = (int) round($amountToRefund * 100);

        return DB::transaction(function () use ($invoice, $payment, $amountCents, $amountToRefund, $reason, $admin) {
            // Issue partial Stripe refund
            $refund = $this->stripe->refundPayment($payment, $amountCents);

            // Update payment
            $payment->update([
                'status' => Payment::STATUS_PARTIALLY_REFUNDED,
                'stripe_refund_id' => $refund->id,
                'refunded_at' => now(),
            ]);

            // Update invoice
            $this->invoices->markPartiallyRefunded($invoice, $amountToRefund);

            // Create audit log
            AuditLog::create([
                'user_id' => $admin?->id,
                'action' => 'invoice_partial_refund',
                'entity_type' => 'invoice',
                'entity_id' => $invoice->id,
                'metadata' => [
                    'reason' => $reason,
                    'payment_id' => $payment->id,
                    'stripe_refund_id' => $refund->id,
                    'amount_refunded' => $amountToRefund,
                    'original_amount' => $payment->amount,
                ],
            ]);

            Log::info('Partial refund processed: ' . $refund->id . ' for invoice: ' . $invoice->id);

            return $payment->fresh();
        });
    }

    /**
     * Handle refund confirmation from Stripe webhook (charge.refunded).
     * This is for reconciliation - refund may have been initiated elsewhere.
     */
    public function handleRefundFromWebhook(string $paymentIntentId, string $refundId, int $amountRefunded): void
    {
        $payment = Payment::where('stripe_payment_intent_id', $paymentIntentId)->first();

        if (!$payment) {
            Log::warning('Payment not found for refund webhook: ' . $paymentIntentId);
            return;
        }

        // Idempotency: skip if already refunded
        if ($payment->isRefunded()) {
            Log::info('Payment already refunded: ' . $paymentIntentId);
            return;
        }

        DB::transaction(function () use ($payment, $refundId, $amountRefunded) {
            // GUARD: Double check not already refunded
            if ($payment->status === Payment::STATUS_REFUNDED) {
                Log::info('Payment already refunded (inside transaction): ' . $payment->id);
                return;
            }

            $amountInDollars = $amountRefunded / 100;
            $isFullRefund = $amountInDollars >= $payment->amount;

            // Update payment
            $payment->update([
                'status' => $isFullRefund ? Payment::STATUS_REFUNDED : Payment::STATUS_PARTIALLY_REFUNDED,
                'stripe_refund_id' => $refundId,
                'refunded_at' => now(),
            ]);

            // Update invoice status based on refund type
            $invoice = $payment->invoice;
            if ($invoice && $invoice->status === 'paid') {
                if ($isFullRefund) {
                    $this->invoices->markRefunded($invoice, 'Refund confirmed via Stripe webhook');
                } else {
                    $this->invoices->markPartiallyRefunded($invoice, $amountInDollars);
                }
            }

            // Audit log for webhook refund
            AuditLog::create([
                'user_id' => null, // System/webhook action
                'action' => 'refund_webhook_received',
                'entity_type' => 'payment',
                'entity_id' => $payment->id,
                'metadata' => [
                    'invoice_id' => $payment->invoice_id,
                    'amount_refunded' => $amountInDollars,
                    'is_full_refund' => $isFullRefund,
                    'stripe_refund_id' => $refundId,
                ],
            ]);

            Log::info('Refund processed from webhook: ' . $refundId . ' for payment: ' . $payment->id);
        });
    }
}


================================================================================
SECTION: app/Models
================================================================================

FILE: app/Models/AuditLog.php
--------------------------------------------------------------------------------
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Model;

class AuditLog extends Model
{
    protected $fillable = [
        'user_id',
        'action',
        'entity_type',
        'entity_id',
        'metadata',
    ];

    protected $casts = [
        'metadata' => 'array',
    ];

    public function user()
    {
        return $this->belongsTo(User::class);
    }
}

FILE: app/Models/Credit.php
--------------------------------------------------------------------------------
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Model;

class Credit extends Model
{
    protected $table = 'lce_user_credits';

    protected $fillable = [
        'user_id',
        'type',
        'description',
        'amount',
        'balance',
        'expires_at',
        'used',
    ];

    protected $casts = [
        'expires_at' => 'datetime',
        'used' => 'boolean',
    ];
}

FILE: app/Models/Invoice.php
--------------------------------------------------------------------------------
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\HasMany;
use Illuminate\Database\Eloquent\Relations\BelongsTo;

class Invoice extends Model
{
    protected $fillable = [
        'stripe_invoice_id',
        'user_id',
        'pickup_id',
        'subscription_id',
        'type',
        'status',
        'currency',
        'subtotal',
        'tax',
        'total',
        'metadata',
        'issued_at',
        'paid_at',
        'refunded_at',
    ];

    protected $casts = [
        'metadata' => 'array',
        'issued_at' => 'datetime',
        'paid_at' => 'datetime',
        'refunded_at' => 'datetime',
    ];

    public function lines(): HasMany
    {
        return $this->hasMany(InvoiceLine::class);
    }

    public function payments(): HasMany
    {
        return $this->hasMany(Payment::class);
    }

    public function user(): BelongsTo
    {
        return $this->belongsTo(User::class);
    }

    public function pickup(): BelongsTo
    {
        return $this->belongsTo(Pickup::class);
    }

    public function subscription(): BelongsTo
    {
        return $this->belongsTo(UserSubscription::class, 'subscription_id');
    }

    /**
     * Check if invoice has an active payment (pending or succeeded).
     */
    public function hasActivePayment(): bool
    {
        return $this->payments()
            ->whereIn('status', [Payment::STATUS_PENDING, Payment::STATUS_SUCCEEDED])
            ->exists();
    }

    /**
     * Check if invoice is already paid.
     */
    public function isPaid(): bool
    {
        return $this->status === 'paid';
    }

    /**
     * Check if invoice is refunded.
     */
    public function isRefunded(): bool
    {
        return $this->status === 'refunded';
    }

    /**
     * Check if invoice is partially refunded.
     */
    public function isPartiallyRefunded(): bool
    {
        return $this->status === 'partially_refunded';
    }
}

FILE: app/Models/InvoiceLine.php
--------------------------------------------------------------------------------
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Model;

class InvoiceLine extends Model
{
    protected $fillable = [
        'invoice_id',
        'type',
        'description',
        'quantity',
        'unit_price',
        'amount',
    ];

    public function invoice()
    {
        return $this->belongsTo(Invoice::class);
    }
}

FILE: app/Models/Payment.php
--------------------------------------------------------------------------------
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;

class Payment extends Model
{
    protected $fillable = [
        'invoice_id',
        'user_id',
        'amount',
        'currency',
        'status',
        'stripe_payment_intent_id',
        'stripe_refund_id',
        'metadata',
        'failure_reason',
        'paid_at',
        'refunded_at',
    ];

    protected $casts = [
        'amount' => 'decimal:2',
        'metadata' => 'array',
        'paid_at' => 'datetime',
        'refunded_at' => 'datetime',
    ];

    /**
     * Status constants
     */
    const STATUS_PENDING = 'pending';
    const STATUS_PROCESSING = 'processing';
    const STATUS_SUCCEEDED = 'succeeded';
    const STATUS_FAILED = 'failed';
    const STATUS_REFUNDED = 'refunded';
    const STATUS_PARTIALLY_REFUNDED = 'partially_refunded';

    public function invoice(): BelongsTo
    {
        return $this->belongsTo(Invoice::class);
    }

    public function user(): BelongsTo
    {
        return $this->belongsTo(User::class);
    }

    public function isPending(): bool
    {
        return $this->status === self::STATUS_PENDING;
    }

    public function isSucceeded(): bool
    {
        return $this->status === self::STATUS_SUCCEEDED;
    }

    public function isRefunded(): bool
    {
        return in_array($this->status, [
            self::STATUS_REFUNDED,
            self::STATUS_PARTIALLY_REFUNDED
        ]);
    }
}

FILE: app/Models/Pickup.php
--------------------------------------------------------------------------------
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;

class Pickup extends Model
{
    use HasFactory;

    protected $table = 'pickups';

    protected $fillable = [
        'user_id',
        'subscription_id',
        'invoice_id',
        'order_type',
        'status',
        'pickup_date',
        'estimated_weight',
        'actual_weight',
        'bags_used',
        'pickup_address',
        'delivery_address',
        'notes',
        'picked_up_at',
        'delivered_at',
    ];

    protected $casts = [
        'pickup_date' => 'date',
        'estimated_weight' => 'decimal:2',
        'actual_weight' => 'decimal:2',
        'picked_up_at' => 'datetime',
        'delivered_at' => 'datetime',
    ];

    const ORDER_TYPES = ['ppo', 'subscription'];

    const STATUSES = [
        'pending_payment',
        'scheduled',
        'picked_up',
        'processing',
        'ready_for_delivery',
        'delivered',
        'cancelled'
    ];

    /**
     * Relationships
     */
    public function user(): BelongsTo
    {
        return $this->belongsTo(User::class);
    }

    public function subscription(): BelongsTo
    {
        return $this->belongsTo(UserSubscription::class, 'subscription_id');
    }

    public function invoice(): BelongsTo
    {
        return $this->belongsTo(Invoice::class);
    }

    /**
     * Scopes
     */
    public function scopeScheduled($query)
    {
        return $query->where('status', 'scheduled');
    }

    public function scopePendingPayment($query)
    {
        return $query->where('status', 'pending_payment');
    }

    public function scopeForUser($query, int $userId)
    {
        return $query->where('user_id', $userId);
    }
}

FILE: app/Models/Role.php
--------------------------------------------------------------------------------
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Model;

class Role extends Model
{
    protected $fillable = ['name'];

    public function users()
    {
        return $this->belongsToMany(User::class, 'user_roles');
    }
}

FILE: app/Models/StripeCustomer.php
--------------------------------------------------------------------------------
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;

class StripeCustomer extends Model
{
    protected $fillable = [
        'user_id',
        'stripe_customer_id',
    ];

    public function user(): BelongsTo
    {
        return $this->belongsTo(User::class);
    }
}

FILE: app/Models/StripeWebhookEvent.php
--------------------------------------------------------------------------------
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Model;

class StripeWebhookEvent extends Model
{
    protected $fillable = [
        'stripe_event_id',
        'type',
        'payload',
        'processed_at',
    ];

    protected $casts = [
        'payload' => 'array',
        'processed_at' => 'datetime',
    ];

    /**
     * Check if this event was already processed.
     */
    public function isProcessed(): bool
    {
        return $this->processed_at !== null;
    }

    /**
     * Mark event as processed.
     */
    public function markProcessed(): void
    {
        $this->update(['processed_at' => now()]);
    }

    /**
     * Find or create event for idempotency check.
     */
    public static function findOrCreateEvent(string $eventId, string $type, array $payload): self
    {
        return self::firstOrCreate(
            ['stripe_event_id' => $eventId],
            ['type' => $type, 'payload' => $payload]
        );
    }
}

FILE: app/Models/SubscriptionBagUsage.php
--------------------------------------------------------------------------------
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Model;

class SubscriptionBagUsage extends Model
{
    protected $table = 'lce_subscription_bag_usage';

    protected $fillable = [
        'user_subscription_id',
        'pickup_id',
        'invoice_id',
        'bags_used',
    ];
}

FILE: app/Models/SubscriptionPlan.php
--------------------------------------------------------------------------------
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Model;

class SubscriptionPlan extends Model
{
    protected $table = 'lce_subscription_plans';

    protected $fillable = [
        'name',
        'slug',
        'description',

        // Bag allocations
        'bags_per_day',
        'bags_per_week',
        'bags_per_month',

        // Pricing
        'price_daily',
        'price_weekly',
        'price_monthly',
        'price_annual',

        // Stripe IDs
        'stripe_product_id',
        'stripe_price_id_daily',
        'stripe_price_id_weekly',
        'stripe_price_id_monthly',
        'stripe_price_id_annual',

        // Overage policy
        'overage_policy',
        'overage_price_per_bag',

        'is_active',
    ];

    protected $casts = [
        'price_daily' => 'decimal:2',
        'price_weekly' => 'decimal:2',
        'price_monthly' => 'decimal:2',
        'price_annual' => 'decimal:2',
        'overage_price_per_bag' => 'decimal:2',
        'is_active' => 'boolean',
    ];

    // Billing cycle constants
    const CYCLE_DAILY = 'daily';
    const CYCLE_WEEKLY = 'weekly';
    const CYCLE_MONTHLY = 'monthly';
    const CYCLE_ANNUAL = 'annual';

    const CYCLES = [
        self::CYCLE_DAILY,
        self::CYCLE_WEEKLY,
        self::CYCLE_MONTHLY,
        self::CYCLE_ANNUAL,
    ];

    // Overage policy constants
    const OVERAGE_BLOCK = 'block';
    const OVERAGE_CHARGE_PPO = 'charge_ppo';

    public function userSubscriptions()
    {
        return $this->hasMany(UserSubscription::class, 'plan_id');
    }

    /**
     * Get price for a specific billing cycle.
     */
    public function getPriceForCycle(string $cycle): ?float
    {
        return match ($cycle) {
            self::CYCLE_DAILY => $this->price_daily,
            self::CYCLE_WEEKLY => $this->price_weekly,
            self::CYCLE_MONTHLY => $this->price_monthly,
            self::CYCLE_ANNUAL => $this->price_annual,
            default => null,
        };
    }

    /**
     * Get bags allocation for a specific billing cycle.
     */
    public function getBagsForCycle(string $cycle): ?int
    {
        return match ($cycle) {
            self::CYCLE_DAILY => $this->bags_per_day,
            self::CYCLE_WEEKLY => $this->bags_per_week,
            self::CYCLE_MONTHLY => $this->bags_per_month,
            self::CYCLE_ANNUAL => $this->bags_per_month * 12,
            default => null,
        };
    }

    /**
     * Get Stripe price ID for a specific billing cycle.
     */
    public function getStripePriceIdForCycle(string $cycle): ?string
    {
        return match ($cycle) {
            self::CYCLE_DAILY => $this->stripe_price_id_daily,
            self::CYCLE_WEEKLY => $this->stripe_price_id_weekly,
            self::CYCLE_MONTHLY => $this->stripe_price_id_monthly,
            self::CYCLE_ANNUAL => $this->stripe_price_id_annual,
            default => null,
        };
    }

    /**
     * Check if plan is synced to Stripe.
     */
    public function isSyncedToStripe(): bool
    {
        return !empty($this->stripe_product_id);
    }

    /**
     * Check if overage should block pickup.
     */
    public function shouldBlockOnOverage(): bool
    {
        return $this->overage_policy === self::OVERAGE_BLOCK;
    }

    /**
     * Check if overage should charge PPO.
     */
    public function shouldChargePPOOnOverage(): bool
    {
        return $this->overage_policy === self::OVERAGE_CHARGE_PPO;
    }
}

FILE: app/Models/Transaction.php
--------------------------------------------------------------------------------
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Model;

class Transaction extends Model
{
    protected $table = 'lce_user_transactions';

    protected $fillable = [
        'user_id',
        'subscription_id',
        'type',
        'amount',
        'description',
        'transactionId',
    ];
}

FILE: app/Models/User.php
--------------------------------------------------------------------------------
<?php

namespace App\Models;

use Illuminate\Foundation\Auth\User as Authenticatable;
use Illuminate\Notifications\Notifiable;
use Laravel\Sanctum\HasApiTokens;
use Illuminate\Database\Eloquent\Factories\HasFactory;

class User extends Authenticatable
{
    use HasApiTokens, HasFactory, Notifiable;

    protected $table = 'lce_user_info';

    protected $fillable = [
        'email',
        'password',
        'first_name',
        'last_name',
        'phone',
        'default_order_type',
        'subscription_id',
    ];

    protected $hidden = [
        'password',
        'remember_token',
    ];

    /**
     * ------------------
     * Relationships
     * ------------------
     */
    public function pickups()
    {
        return $this->hasMany(Pickup::class, 'user_id');
    }

    public function invoices()
    {
        return $this->hasMany(Invoice::class, 'user_id');
    }

    public function transactions()
    {
        return $this->hasMany(Transaction::class, 'user_id');
    }

    public function credits()
    {
        return $this->hasMany(Credit::class, 'user_id');
    }

    public function subscriptions()
    {
        return $this->hasMany(UserSubscription::class, 'user_id');
    }

    public function activeSubscription()
    {
        return $this->belongsTo(UserSubscription::class, 'subscription_id');
    }

    /**
     * ------------------
     * Roles & Permissions
     * ------------------
     */
    public function roles()
    {
        return $this->belongsToMany(Role::class, 'user_roles');
    }

    public function hasRole(string $role): bool
    {
        return $this->roles()->where('name', $role)->exists();
    }
}

FILE: app/Models/UserSubscription.php
--------------------------------------------------------------------------------
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Model;

class UserSubscription extends Model
{
    protected $table = 'lce_user_subscriptions';

    // Status constants
    const STATUS_PENDING = 'pending';
    const STATUS_ACTIVE = 'active';
    const STATUS_PAUSED = 'paused';
    const STATUS_PAST_DUE = 'past_due';
    const STATUS_CANCELLED = 'cancelled';
    const STATUS_UPGRADED = 'upgraded';
    const STATUS_DOWNGRADED = 'downgraded';

    protected $fillable = [
        'user_id',
        'plan_id',
        'pending_plan_id',
        'pending_billing_cycle',

        // Stripe IDs
        'stripe_subscription_id',
        'stripe_customer_id',
        'stripe_schedule_id',

        // Status
        'status',
        'cancel_at_period_end',
        'cancel_reason',
        'cancelled_at',

        // Billing cycle
        'billing_cycle',

        // Dates
        'start_date',
        'end_date',
        'next_renewal_date',
        'current_period_start',
        'current_period_end',

        // Bag tracking
        'bags_plan_period',
        'bags_plan_total',
        'bags_plan_balance',
        'bags_plan_used',
        'bags_available',

        // Payment tracking
        'payment_last',
        'payment_discount',
        'payment_balance',

        // Proration
        'manual_proration_applied',
        'manual_proration_amount',

        'notes',
    ];

    protected $casts = [
        'start_date' => 'date',
        'end_date' => 'date',
        'next_renewal_date' => 'date',
        'current_period_start' => 'datetime',
        'current_period_end' => 'datetime',
        'cancelled_at' => 'datetime',
        'cancel_at_period_end' => 'boolean',
        'manual_proration_applied' => 'boolean',
        'payment_last' => 'decimal:2',
        'payment_discount' => 'decimal:2',
        'payment_balance' => 'decimal:2',
        'manual_proration_amount' => 'decimal:2',
    ];

    public function user()
    {
        return $this->belongsTo(User::class);
    }

    public function plan()
    {
        return $this->belongsTo(SubscriptionPlan::class, 'plan_id');
    }

    public function pendingPlan()
    {
        return $this->belongsTo(SubscriptionPlan::class, 'pending_plan_id');
    }

    public function bagUsages()
    {
        return $this->hasMany(SubscriptionBagUsage::class, 'user_subscription_id');
    }

    public function pickups()
    {
        return $this->hasMany(Pickup::class, 'subscription_id');
    }

    public function invoices()
    {
        return $this->hasMany(Invoice::class, 'subscription_id');
    }

    /**
     * Check if subscription is active.
     */
    public function isActive(): bool
    {
        return $this->status === self::STATUS_ACTIVE;
    }

    /**
     * Check if subscription is cancelled.
     */
    public function isCancelled(): bool
    {
        return $this->status === self::STATUS_CANCELLED;
    }

    /**
     * Check if subscription is pending cancellation at period end.
     */
    public function isPendingCancellation(): bool
    {
        return $this->cancel_at_period_end && $this->isActive();
    }

    /**
     * Check if subscription is past due.
     */
    public function isPastDue(): bool
    {
        return $this->status === self::STATUS_PAST_DUE;
    }

    /**
     * Check if subscription has pending plan change.
     */
    public function hasPendingPlanChange(): bool
    {
        return !is_null($this->pending_plan_id);
    }

    /**
     * Check if subscription is synced to Stripe.
     */
    public function isSyncedToStripe(): bool
    {
        return !empty($this->stripe_subscription_id);
    }

    /**
     * Get remaining bags for current period.
     */
    public function getRemainingBags(): int
    {
        return max(0, $this->bags_plan_total - $this->bags_plan_used);
    }

    /**
     * Check if user can use another bag.
     */
    public function canUseBag(): bool
    {
        if (!$this->isActive()) {
            return false;
        }

        // If overage policy allows PPO, always allow
        if ($this->plan && $this->plan->shouldChargePPOOnOverage()) {
            return true;
        }

        // Otherwise, check remaining bags
        return $this->getRemainingBags() > 0;
    }

    /**
     * Check if current usage is over limit.
     */
    public function isOverLimit(): bool
    {
        return $this->bags_plan_used >= $this->bags_plan_total;
    }
}


================================================================================
SECTION: app/Http/Controllers/Api/V1
================================================================================

FILE: app/Http/Controllers/Api/V1/AuthController.php
--------------------------------------------------------------------------------
<?php

namespace App\Http\Controllers\Api\V1;

use App\Http\Controllers\Controller;
use App\Models\User;
use Illuminate\Http\JsonResponse;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Hash;
use Illuminate\Validation\ValidationException;

class AuthController extends Controller
{
    /**
     * Register a new user.
     *
     * POST /api/v1/auth/register
     */
    public function register(Request $request): JsonResponse
    {
        $validated = $request->validate([
            'email'      => 'required|email|unique:lce_user_info,email',
            'password'   => 'required|string|min:8|confirmed',
            'first_name' => 'required|string|max:255',
            'last_name'  => 'required|string|max:255',
            'phone'      => 'nullable|string|max:20',
        ]);

        $user = User::create([
            'email'      => $validated['email'],
            'password'   => Hash::make($validated['password']),
            'first_name' => $validated['first_name'],
            'last_name'  => $validated['last_name'],
            'phone'      => $validated['phone'] ?? null,
        ]);

        $token = $user->createToken('auth_token')->plainTextToken;

        return response()->json([
            'success' => true,
            'message' => 'User registered successfully.',
            'data' => [
                'user' => $this->formatUser($user),
                'token' => $token,
                'token_type' => 'Bearer',
            ],
        ], 201);
    }

    /**
     * Login and issue token.
     *
     * POST /api/v1/auth/login
     */
    public function login(Request $request): JsonResponse
    {
        $validated = $request->validate([
            'email'    => 'required|email',
            'password' => 'required|string',
        ]);

        $user = User::where('email', $validated['email'])->first();

        if (!$user || !Hash::check($validated['password'], $user->password)) {
            throw ValidationException::withMessages([
                'email' => ['The provided credentials are incorrect.'],
            ]);
        }

        // Revoke all previous tokens (prevents multiple active sessions)
        $user->tokens()->delete();

        $token = $user->createToken('auth_token')->plainTextToken;

        return response()->json([
            'success' => true,
            'message' => 'Login successful.',
            'data' => [
                'user' => $this->formatUser($user),
                'token' => $token,
                'token_type' => 'Bearer',
            ],
        ]);
    }

    /**
     * Logout and revoke current token.
     *
     * POST /api/v1/auth/logout
     */
    public function logout(Request $request): JsonResponse
    {
        $request->user()->currentAccessToken()->delete();

        return response()->json([
            'success' => true,
            'message' => 'Logged out successfully.',
        ]);
    }

    /**
     * Get authenticated user info.
     *
     * GET /api/v1/auth/me
     */
    public function me(Request $request): JsonResponse
    {
        return response()->json([
            'success' => true,
            'data' => $this->formatUser($request->user()),
        ]);
    }

    /**
     * Format user data for API response.
     */
    private function formatUser(User $user): array
    {
        return [
            'id'         => $user->id,
            'email'      => $user->email,
            'first_name' => $user->first_name,
            'last_name'  => $user->last_name,
            'phone'      => $user->phone,
            'roles'      => $user->roles->pluck('name')->toArray(),
        ];
    }
}

FILE: app/Http/Controllers/Api/V1/BillingController.php
--------------------------------------------------------------------------------
<?php

namespace App\Http\Controllers\Api\V1;

use App\Http\Controllers\Controller;
use Illuminate\Http\Request;
use App\Services\Billing\BillingService;

class BillingController extends Controller
{
    protected BillingService $billing;

    public function __construct(BillingService $billing)
    {
        $this->billing = $billing;
    }

    /**
     * PPO price preview
     */
    public function ppoPreview(Request $request)
    {
        $data = $request->validate([
            'weight_lbs' => 'required|numeric|min:0.1',
        ]);

        // Example static values (later from DB)
        $result = $this->billing->billPPO(
            $request->user(),
            $data['weight_lbs'],
            1.99,   // price per lb
            30.00,  // minimum
            5.00,   // pickup fee
            3.00    // service fee
        );

        return response()->json([
            'success' => true,
            'data' => $result,
        ]);
    }
}

FILE: app/Http/Controllers/Api/V1/CreditController.php
--------------------------------------------------------------------------------
<?php

namespace App\Http\Controllers\Api\V1;

use App\Http\Controllers\Controller;
use Illuminate\Http\Request;
use App\Services\Credit\CreditService;

class CreditController extends Controller
{
    protected CreditService $credits;

    public function __construct(CreditService $credits)
    {
        $this->credits = $credits;
    }

    public function index(Request $request)
    {
        return response()->json([
            'success' => true,
            'balance' => $this->credits->getAvailableBalance($request->user()),
        ]);
    }
}

FILE: app/Http/Controllers/Api/V1/InvoiceController.php
--------------------------------------------------------------------------------
<?php

namespace App\Http\Controllers\Api\V1;

use App\Http\Controllers\Controller;
use App\Models\Invoice;
use App\Services\Invoice\InvoiceService;
use Illuminate\Http\Request;

class InvoiceController extends Controller
{
    protected InvoiceService $invoiceService;

    public function __construct(InvoiceService $invoiceService)
    {
        $this->invoiceService = $invoiceService;
    }

    /**
     * GET /api/v1/invoices
     * List invoices for current user (latest first)
     */
    public function index(Request $request)
    {
        $user = $request->user();

        $query = Invoice::query()
            ->with('lines')
            ->where('user_id', $user->id)
            ->latest();

        return response()->json([
            'success' => true,
            'data' => $query->paginate(15),
        ]);
    }

    /**
     * GET /api/v1/invoices/{invoice}
     * Show single invoice (ownership check)
     */
    public function show(Request $request, Invoice $invoice)
    {
        $user = $request->user();

        // Ownership check: user can only view their own invoices
        if ($invoice->user_id !== $user->id && !$user->hasRole('admin')) {
            return response()->json([
                'success' => false,
                'message' => 'Unauthorized to view this invoice.',
            ], 403);
        }

        return response()->json([
            'success' => true,
            'data' => $invoice->load('lines'),
        ]);
    }

    /**
     * POST /api/v1/invoices/{invoice}/pay
     * Move invoice to pending_payment (ownership check)
     */
    public function pay(Request $request, Invoice $invoice)
    {
        $user = $request->user();

        // Ownership check: user can only pay their own invoices
        if ($invoice->user_id !== $user->id && !$user->hasRole('admin')) {
            return response()->json([
                'success' => false,
                'message' => 'Unauthorized to pay this invoice.',
            ], 403);
        }

        $invoice = $this->invoiceService->markPendingPayment($invoice);

        return response()->json([
            'success' => true,
            'data' => $invoice->fresh()->load('lines'),
        ]);
    }
}

FILE: app/Http/Controllers/Api/V1/PaymentController.php
--------------------------------------------------------------------------------
<?php

namespace App\Http\Controllers\Api\V1;

use App\Http\Controllers\Controller;
use App\Models\Invoice;
use App\Services\Payment\PaymentService;
use Illuminate\Http\JsonResponse;
use Illuminate\Http\Request;

class PaymentController extends Controller
{
    protected PaymentService $paymentService;

    public function __construct(PaymentService $paymentService)
    {
        $this->paymentService = $paymentService;
    }

    /**
     * Create a Payment Intent for an invoice.
     * 
     * POST /api/v1/payments/intent
     */
    public function createIntent(Request $request): JsonResponse
    {
        $request->validate([
            'invoice_id' => 'required|integer|exists:invoices,id',
        ]);

        $invoice = Invoice::findOrFail($request->invoice_id);
        $user = $request->user();

        // Authorization: user can only pay their own invoices
        if ($invoice->user_id !== $user->id) {
            return response()->json([
                'success' => false,
                'message' => 'Unauthorized to pay this invoice.',
            ], 403);
        }

        try {
            $result = $this->paymentService->createPaymentIntent($invoice, $user);

            return response()->json([
                'success' => true,
                'message' => 'Payment intent created.',
                'data' => [
                    'client_secret' => $result['client_secret'],
                    'payment_intent_id' => $result['payment_intent_id'],
                    'amount' => $result['amount'],
                    'currency' => $result['currency'],
                ],
            ]);
        } catch (\DomainException $e) {
            return response()->json([
                'success' => false,
                'message' => $e->getMessage(),
            ], 422);
        } catch (\Exception $e) {
            return response()->json([
                'success' => false,
                'message' => 'Failed to create payment intent.',
            ], 500);
        }
    }

    /**
     * Get payment status for an invoice.
     * 
     * GET /api/v1/payments/status/{invoice}
     */
    public function status(Invoice $invoice, Request $request): JsonResponse
    {
        $user = $request->user();

        // Authorization
        if ($invoice->user_id !== $user->id) {
            return response()->json([
                'success' => false,
                'message' => 'Unauthorized.',
            ], 403);
        }

        $payment = $this->paymentService->getPaymentByInvoice($invoice->id);

        return response()->json([
            'success' => true,
            'data' => [
                'invoice_status' => $invoice->status,
                'payment' => $payment ? [
                    'id' => $payment->id,
                    'status' => $payment->status,
                    'amount' => $payment->amount,
                    'paid_at' => $payment->paid_at,
                ] : null,
            ],
        ]);
    }
}

FILE: app/Http/Controllers/Api/V1/PickupController.php
--------------------------------------------------------------------------------
<?php

namespace App\Http\Controllers\Api\V1;

use App\Http\Controllers\Controller;
use Illuminate\Http\JsonResponse;
use Illuminate\Http\Request;
use App\Services\Pickup\PickupService;
use App\Services\Invoice\InvoiceService;
use App\Models\Invoice;
use App\Models\UserSubscription;

class PickupController extends Controller
{
    protected PickupService $pickupService;
    protected InvoiceService $invoiceService;

    public function __construct(
        PickupService $pickupService,
        InvoiceService $invoiceService
    ) {
        $this->pickupService = $pickupService;
        $this->invoiceService = $invoiceService;
    }

    /**
     * Preview a pickup (does NOT persist anything).
     * 
     * POST /api/v1/pickups/preview
     */
    public function preview(Request $request): JsonResponse
    {
        $data = $request->validate([
            'order_type' => 'required|in:PPO,subscription',
            'pickup_date' => 'nullable|date',
            'estimated_weight' => 'nullable|numeric|min:0',
            'bags' => 'nullable|integer|min:1',
        ]);

        $user = $request->user();

        if ($data['order_type'] === 'PPO') {
            $result = $this->pickupService->createPPOPickup($user, $data);
        } else {
            $subscription = UserSubscription::where('user_id', $user->id)
                ->where('status', 'active')
                ->firstOrFail();

            $result = $this->pickupService->createSubscriptionPickup(
                $user,
                $subscription,
                $data
            );
        }

        return response()->json([
            'success' => true,
            'message' => 'Pickup preview generated. Use /pickups/confirm to finalize.',
            'data' => [
                'pickup_preview' => $result['pickup_payload'],
                'billing_preview' => $result['billing_preview'],
                'invoice_preview' => $result['invoice_preview'],
            ],
        ]);
    }

    /**
     * Confirm and persist a pickup + invoice atomically.
     * 
     * POST /api/v1/pickups/confirm
     */
    public function confirm(Request $request): JsonResponse
    {
        $data = $request->validate([
            'order_type' => 'required|in:PPO,subscription',
            'pickup_date' => 'required|date',
            'estimated_weight' => 'nullable|numeric|min:0',
            'bags' => 'nullable|integer|min:1',
            'subscription_id' => 'nullable|integer',
            'invoice_type' => 'required|string',
            'billing_preview' => 'required|array',
        ]);

        $result = $this->pickupService->confirmPickup(
            $request->user(),
            $data
        );

        return response()->json([
            'success' => true,
            'message' => 'Pickup confirmed and invoice created.',
            'data' => $result,
        ]);
    }

    /**
     * Update a pickup (placeholder for future implementation).
     * 
     * PUT /api/v1/pickups/{id}
     */
    public function update(Request $request, int $id): JsonResponse
    {
        // TODO: Implement pickup update logic
        return response()->json([
            'success' => false,
            'message' => 'Pickup update not yet implemented.',
        ], 501);
    }
}

FILE: app/Http/Controllers/Api/V1/StripeWebhookController.php
--------------------------------------------------------------------------------
<?php

namespace App\Http\Controllers\Api\V1;

use App\Http\Controllers\Controller;
use App\Models\StripeWebhookEvent;
use App\Services\Stripe\StripeService;
use App\Services\Payment\PaymentService;
use App\Services\Payment\RefundService;
use App\Services\Subscription\SubscriptionWebhookHandler;
use Illuminate\Http\Request;
use Illuminate\Http\JsonResponse;
use Illuminate\Support\Facades\Log;

class StripeWebhookController extends Controller
{
    protected StripeService $stripeService;
    protected PaymentService $paymentService;
    protected RefundService $refundService;
    protected SubscriptionWebhookHandler $subscriptionHandler;

    public function __construct(
        StripeService $stripeService,
        PaymentService $paymentService,
        RefundService $refundService,
        SubscriptionWebhookHandler $subscriptionHandler
    ) {
        $this->stripeService = $stripeService;
        $this->paymentService = $paymentService;
        $this->refundService = $refundService;
        $this->subscriptionHandler = $subscriptionHandler;
    }

    /**
     * Handle Stripe webhook events.
     * 
     * POST /api/v1/webhooks/stripe
     */
    public function handle(Request $request): JsonResponse
    {
        $payload = $request->getContent();
        $signature = $request->header('Stripe-Signature');

        if (!$signature) {
            Log::warning('Stripe webhook: Missing signature');
            return response()->json(['error' => 'Missing signature'], 400);
        }

        // Verify webhook signature
        try {
            $event = $this->stripeService->constructWebhookEvent($payload, $signature);
        } catch (\RuntimeException $e) {
            Log::warning('Stripe webhook: ' . $e->getMessage());
            return response()->json(['error' => 'Invalid signature'], 400);
        }

        // Idempotency check: store event
        $webhookEvent = StripeWebhookEvent::findOrCreateEvent(
            $event->id,
            $event->type,
            $event->toArray()
        );

        if ($webhookEvent->isProcessed()) {
            Log::info('Stripe webhook: Event already processed - ' . $event->id);
            return response()->json(['status' => 'already_processed']);
        }

        // Handle event types
        try {
            $this->processEvent($event);
            $webhookEvent->markProcessed();

            return response()->json(['status' => 'success']);
        } catch (\Exception $e) {
            Log::error('Stripe webhook processing failed: ' . $e->getMessage(), [
                'event_id' => $event->id,
                'type' => $event->type,
                'trace' => $e->getTraceAsString(),
            ]);

            return response()->json(['error' => 'Processing failed'], 500);
        }
    }

    /**
     * Process specific event types.
     */
    protected function processEvent(\Stripe\Event $event): void
    {
        $object = $event->data->object;

        switch ($event->type) {
            // ===============================
            // Payment Intent Events (PPO)
            // ===============================
            case 'payment_intent.succeeded':
                Log::info('Processing payment_intent.succeeded: ' . $object->id);
                $this->paymentService->markPaymentSucceeded($object->id);
                break;

            case 'payment_intent.payment_failed':
                Log::info('Processing payment_intent.payment_failed: ' . $object->id);
                $failureMessage = $object->last_payment_error->message ?? 'Payment failed';
                $this->paymentService->markPaymentFailed($object->id, $failureMessage);
                break;

            case 'charge.refunded':
                Log::info('Processing charge.refunded: ' . $object->id);
                $paymentIntentId = $object->payment_intent;
                $refundId = $object->refunds->data[0]->id ?? null;
                $amountRefunded = $object->amount_refunded ?? 0;

                if ($paymentIntentId && $refundId) {
                    // Handle PPO refunds
                    $this->refundService->handleRefundFromWebhook(
                        $paymentIntentId,
                        $refundId,
                        $amountRefunded
                    );

                    // Handle subscription refunds (partial refund support)
                    $this->subscriptionHandler->handleChargeRefunded($object);
                }
                break;

            // ===============================
            // Subscription Invoice Events
            // ===============================
            case 'invoice.paid':
                Log::info('Processing invoice.paid: ' . $object->id);
                $this->subscriptionHandler->handleInvoicePaid($object);
                break;

            case 'invoice.payment_failed':
                Log::info('Processing invoice.payment_failed: ' . $object->id);
                $this->subscriptionHandler->handleInvoicePaymentFailed($object);
                break;

            case 'invoice.finalized':
                Log::info('Processing invoice.finalized: ' . $object->id);
                $this->subscriptionHandler->handleInvoiceFinalized($object);
                break;

            // ===============================
            // Subscription Lifecycle Events
            // ===============================
            case 'customer.subscription.updated':
                Log::info('Processing customer.subscription.updated: ' . $object->id);
                $this->subscriptionHandler->handleSubscriptionUpdated($object);
                break;

            case 'customer.subscription.deleted':
                Log::info('Processing customer.subscription.deleted: ' . $object->id);
                $this->subscriptionHandler->handleSubscriptionDeleted($object);
                break;

            case 'customer.subscription.created':
                Log::info('Subscription created in Stripe: ' . $object->id);
                // Typically handled during local subscription creation
                break;

            default:
                Log::info('Unhandled Stripe event type: ' . $event->type);
        }
    }
}

FILE: app/Http/Controllers/Api/V1/SubscriptionController.php
--------------------------------------------------------------------------------
<?php

namespace App\Http\Controllers\Api\V1;

use App\Http\Controllers\Controller;
use Illuminate\Http\Request;
use Illuminate\Http\JsonResponse;
use App\Services\Subscription\SubscriptionService;
use App\Models\SubscriptionPlan;
use App\Models\UserSubscription;

class SubscriptionController extends Controller
{
    protected SubscriptionService $subscriptions;

    public function __construct(SubscriptionService $subscriptions)
    {
        $this->subscriptions = $subscriptions;
    }

    /**
     * List available subscription plans.
     */
    public function plans(): JsonResponse
    {
        $plans = SubscriptionPlan::where('is_active', true)
            ->select([
                'id',
                'name',
                'slug',
                'description',
                'bags_per_day',
                'bags_per_week',
                'bags_per_month',
                'price_daily',
                'price_weekly',
                'price_monthly',
                'price_annual',
                'overage_policy',
                'overage_price_per_bag',
            ])
            ->get();

        return response()->json([
            'success' => true,
            'data' => $plans,
        ]);
    }

    /**
     * Get current user's active subscription.
     */
    public function current(Request $request): JsonResponse
    {
        $user = $request->user();

        $subscription = $user->subscriptions()
            ->with('plan')
            ->whereIn('status', [
                UserSubscription::STATUS_ACTIVE,
                UserSubscription::STATUS_PAUSED,
                UserSubscription::STATUS_PENDING,
            ])
            ->first();

        if (!$subscription) {
            return response()->json([
                'success' => true,
                'data' => null,
                'message' => 'No active subscription.',
            ]);
        }

        return response()->json([
            'success' => true,
            'data' => [
                'subscription' => $subscription,
                'bags_remaining' => $subscription->getRemainingBags(),
                'is_pending_cancellation' => $subscription->isPendingCancellation(),
                'has_pending_plan_change' => $subscription->hasPendingPlanChange(),
                'pending_plan' => $subscription->pendingPlan,
            ],
        ]);
    }

    /**
     * Create a new subscription.
     * Returns client_secret for payment confirmation.
     */
    public function store(Request $request): JsonResponse
    {
        $data = $request->validate([
            'plan_id' => 'required|exists:lce_subscription_plans,id',
            'billing_cycle' => 'required|in:daily,weekly,monthly,annual',
        ]);

        $plan = SubscriptionPlan::findOrFail($data['plan_id']);

        if (!$plan->is_active) {
            return response()->json([
                'success' => false,
                'message' => 'This plan is no longer available.',
            ], 422);
        }

        try {
            $result = $this->subscriptions->create(
                $request->user(),
                $plan,
                $data['billing_cycle']
            );

            return response()->json([
                'success' => true,
                'data' => [
                    'subscription' => $result['subscription'],
                    'client_secret' => $result['client_secret'],
                    'stripe_subscription_id' => $result['stripe_subscription_id'],
                ],
                'message' => 'Subscription created. Complete payment to activate.',
            ]);
        } catch (\DomainException $e) {
            return response()->json([
                'success' => false,
                'message' => $e->getMessage(),
            ], 422);
        } catch (\Exception $e) {
            return response()->json([
                'success' => false,
                'message' => 'Failed to create subscription. Please try again.',
            ], 500);
        }
    }

    /**
     * Cancel subscription (at period end).
     */
    public function cancel(Request $request, int $id): JsonResponse
    {
        $user = $request->user();
        $subscription = UserSubscription::findOrFail($id);

        // Ownership check
        if ($subscription->user_id !== $user->id && !$user->hasRole('admin')) {
            return response()->json([
                'success' => false,
                'message' => 'Unauthorized to cancel this subscription.',
            ], 403);
        }

        try {
            $cancelled = $this->subscriptions->cancel(
                $subscription,
                $request->input('reason')
            );

            return response()->json([
                'success' => true,
                'data' => $cancelled,
                'message' => $cancelled->cancel_at_period_end
                    ? 'Subscription will be cancelled at the end of the current billing period.'
                    : 'Subscription cancelled.',
            ]);
        } catch (\DomainException $e) {
            return response()->json([
                'success' => false,
                'message' => $e->getMessage(),
            ], 422);
        }
    }

    /**
     * Reactivate a subscription scheduled for cancellation.
     */
    public function reactivate(Request $request, int $id): JsonResponse
    {
        $user = $request->user();
        $subscription = UserSubscription::findOrFail($id);

        // Ownership check
        if ($subscription->user_id !== $user->id && !$user->hasRole('admin')) {
            return response()->json([
                'success' => false,
                'message' => 'Unauthorized to reactivate this subscription.',
            ], 403);
        }

        try {
            $reactivated = $this->subscriptions->reactivate($subscription);

            return response()->json([
                'success' => true,
                'data' => $reactivated,
                'message' => 'Subscription reactivated successfully.',
            ]);
        } catch (\DomainException $e) {
            return response()->json([
                'success' => false,
                'message' => $e->getMessage(),
            ], 422);
        }
    }

    /**
     * Upgrade subscription to a higher plan.
     */
    public function upgrade(Request $request, int $id): JsonResponse
    {
        $data = $request->validate([
            'new_plan_id' => 'required|exists:lce_subscription_plans,id',
            'new_billing_cycle' => 'nullable|in:daily,weekly,monthly,annual',
        ]);

        $user = $request->user();
        $subscription = UserSubscription::findOrFail($id);

        // Ownership check
        if ($subscription->user_id !== $user->id && !$user->hasRole('admin')) {
            return response()->json([
                'success' => false,
                'message' => 'Unauthorized to upgrade this subscription.',
            ], 403);
        }

        $newPlan = SubscriptionPlan::findOrFail($data['new_plan_id']);

        try {
            $upgraded = $this->subscriptions->upgrade(
                $subscription,
                $newPlan,
                $data['new_billing_cycle'] ?? null
            );

            return response()->json([
                'success' => true,
                'data' => $upgraded,
                'message' => 'Subscription upgraded successfully. Prorated charge will be applied.',
            ]);
        } catch (\DomainException $e) {
            return response()->json([
                'success' => false,
                'message' => $e->getMessage(),
            ], 422);
        }
    }

    /**
     * Downgrade subscription to a lower plan (effective at period end).
     */
    public function downgrade(Request $request, int $id): JsonResponse
    {
        $data = $request->validate([
            'new_plan_id' => 'required|exists:lce_subscription_plans,id',
            'new_billing_cycle' => 'nullable|in:daily,weekly,monthly,annual',
        ]);

        $user = $request->user();
        $subscription = UserSubscription::findOrFail($id);

        // Ownership check
        if ($subscription->user_id !== $user->id && !$user->hasRole('admin')) {
            return response()->json([
                'success' => false,
                'message' => 'Unauthorized to downgrade this subscription.',
            ], 403);
        }

        $newPlan = SubscriptionPlan::findOrFail($data['new_plan_id']);

        try {
            $downgraded = $this->subscriptions->downgrade(
                $subscription,
                $newPlan,
                $data['new_billing_cycle'] ?? null
            );

            return response()->json([
                'success' => true,
                'data' => $downgraded,
                'message' => 'Downgrade scheduled for end of current billing period.',
            ]);
        } catch (\DomainException $e) {
            return response()->json([
                'success' => false,
                'message' => $e->getMessage(),
            ], 422);
        }
    }

    /**
     * Pause subscription billing.
     * POST /api/v1/subscriptions/{id}/pause
     */
    public function pause(Request $request, int $id): JsonResponse
    {
        $user = $request->user();
        $subscription = UserSubscription::where('id', $id)
            ->where('user_id', $user->id)
            ->firstOrFail();

        $data = $request->validate([
            'reason' => 'nullable|string|max:500',
        ]);

        try {
            $paused = $this->subscriptions->pause($subscription, $data['reason'] ?? null);

            return response()->json([
                'success' => true,
                'data' => $paused,
                'message' => 'Subscription billing paused successfully.',
            ]);
        } catch (\DomainException $e) {
            return response()->json([
                'success' => false,
                'message' => $e->getMessage(),
            ], 422);
        }
    }

    /**
     * Resume paused subscription.
     * POST /api/v1/subscriptions/{id}/resume
     */
    public function resume(Request $request, int $id): JsonResponse
    {
        $user = $request->user();
        $subscription = UserSubscription::where('id', $id)
            ->where('user_id', $user->id)
            ->firstOrFail();

        try {
            $resumed = $this->subscriptions->resume($subscription);

            return response()->json([
                'success' => true,
                'data' => $resumed,
                'message' => 'Subscription billing resumed successfully.',
            ]);
        } catch (\DomainException $e) {
            return response()->json([
                'success' => false,
                'message' => $e->getMessage(),
            ], 422);
        }
    }

    /**
     * Check if pickup can proceed based on subscription.
     * GET /api/v1/subscriptions/check-pickup
     */
    public function checkPickup(Request $request): JsonResponse
    {
        $user = $request->user();
        $subscription = $user->subscriptions()
            ->where('status', UserSubscription::STATUS_ACTIVE)
            ->with('plan')
            ->first();

        if (!$subscription) {
            return response()->json([
                'allowed' => false,
                'reason' => 'No active subscription',
                'requires_ppo' => false,
            ]);
        }

        $data = $request->validate([
            'bags' => 'nullable|integer|min:1',
        ]);

        $bags = $data['bags'] ?? 1;
        $result = $this->subscriptions->canProceedWithPickup($subscription, $bags);

        return response()->json($result);
    }
}


================================================================================
SECTION: app/Http/Controllers/Api/V1/Admin
================================================================================

FILE: app/Http/Controllers/Api/V1/Admin/AdminDashboardController.php
--------------------------------------------------------------------------------
<?php

namespace App\Http\Controllers\Api\V1\Admin;

use App\Http\Controllers\Controller;
use App\Models\Invoice;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\DB;


class AdminDashboardController extends Controller
{
    /**
     * GET /api/v1/admin/dashboard/summary
     */
    public function summary()
    {
        $paidInvoices = Invoice::where('status', 'paid');

        return response()->json([
            'success' => true,
            'data' => [
                'total_revenue' => $paidInvoices->sum('total'),
                'total_invoices' => Invoice::count(),
                'paid_invoices' => Invoice::where('status', 'paid')->count(),
                'refunded_invoices' => Invoice::where('status', 'refunded')->count(),
                'average_order_value' => round(
                    $paidInvoices->avg('total') ?? 0,
                    2
                ),
            ],
        ]);
    }

    /**
     * GET /api/v1/admin/dashboard/revenue
     * ?from=YYYY-MM-DD&to=YYYY-MM-DD
     */
    public function revenue(Request $request)
    {
        $query = Invoice::where('status', 'paid');

        if ($request->filled('from')) {
            $query->whereDate('paid_at', '>=', $request->from);
        }

        if ($request->filled('to')) {
            $query->whereDate('paid_at', '<=', $request->to);
        }

        $data = $query
            ->select(
                DB::raw('DATE(paid_at) as date'),
                DB::raw('SUM(total) as revenue'),
                DB::raw('COUNT(*) as invoices')
            )
            ->groupBy(DB::raw('DATE(paid_at)'))
            ->orderBy('date')
            ->get();

        return response()->json([
            'success' => true,
            'data' => $data,
        ]);
    }
}

FILE: app/Http/Controllers/Api/V1/Admin/AdminInvoiceController.php
--------------------------------------------------------------------------------
<?php

namespace App\Http\Controllers\Api\V1\Admin;

use App\Http\Controllers\Controller;
use App\Models\Invoice;
use App\Services\Payment\RefundService;
use Illuminate\Http\Request;
use Symfony\Component\HttpFoundation\StreamedResponse;

class AdminInvoiceController extends Controller
{
    protected RefundService $refundService;

    public function __construct(RefundService $refundService)
    {
        $this->refundService = $refundService;
    }


    public function index(Request $request)
    {
        $query = Invoice::query()->with('lines')->latest();

        if ($request->filled('status')) {
            $query->where('status', $request->status);
        }

        if ($request->filled('type')) {
            $query->where('type', $request->type);
        }

        if ($request->filled('user_id')) {
            $query->where('user_id', $request->user_id);
        }

        if ($request->filled('from')) {
            $query->whereDate('created_at', '>=', $request->from);
        }

        if ($request->filled('to')) {
            $query->whereDate('created_at', '<=', $request->to);
        }

        if ($request->filled('min')) {
            $query->where('total', '>=', $request->min);
        }

        if ($request->filled('max')) {
            $query->where('total', '<=', $request->max);
        }

        return response()->json([
            'success' => true,
            'data' => $query->paginate(25),
        ]);
    }

    public function export(Request $request): StreamedResponse
    {
        $query = Invoice::query()->latest();

        foreach (['status', 'type', 'user_id'] as $field) {
            if ($request->filled($field)) {
                $query->where($field, $request->$field);
            }
        }

        if ($request->filled('from')) {
            $query->whereDate('created_at', '>=', $request->from);
        }

        if ($request->filled('to')) {
            $query->whereDate('created_at', '<=', $request->to);
        }

        $invoices = $query->get();

        return response()->streamDownload(function () use ($invoices) {
            $handle = fopen('php://output', 'w');

            fputcsv($handle, [
                'Invoice ID',
                'User ID',
                'Type',
                'Status',
                'Subtotal',
                'Tax',
                'Total',
                'Currency',
                'Created At'
            ]);

            foreach ($invoices as $invoice) {
                fputcsv($handle, [
                    $invoice->id,
                    $invoice->user_id,
                    $invoice->type,
                    $invoice->status,
                    $invoice->subtotal,
                    $invoice->tax,
                    $invoice->total,
                    $invoice->currency,
                    $invoice->created_at,
                ]);
            }

            fclose($handle);
        }, 'invoices_export.csv');
    }

    /**
     * Refund an invoice via Stripe.
     */
    public function refund(Request $request, Invoice $invoice)
    {
        $request->validate([
            'reason' => 'required|string|max:255',
        ]);

        if ($invoice->status !== 'paid') {
            return response()->json([
                'success' => false,
                'message' => 'Only paid invoices can be refunded.',
            ], 422);
        }

        try {
            $payment = $this->refundService->processRefund(
                $invoice,
                $request->reason,
                $request->user() // admin user for audit log
            );

            return response()->json([
                'success' => true,
                'message' => 'Refund processed successfully.',
                'data' => [
                    'invoice' => $invoice->fresh()->load('lines'),
                    'payment' => $payment,
                ],
            ]);
        } catch (\DomainException $e) {
            return response()->json([
                'success' => false,
                'message' => $e->getMessage(),
            ], 422);
        } catch (\Exception $e) {
            return response()->json([
                'success' => false,
                'message' => 'Refund failed. Please try again.',
            ], 500);
        }
    }
}

FILE: app/Http/Controllers/Api/V1/Admin/AdminSubscriptionController.php
--------------------------------------------------------------------------------
<?php

namespace App\Http\Controllers\Api\V1\Admin;

use App\Http\Controllers\Controller;
use App\Models\SubscriptionPlan;
use App\Models\UserSubscription;
use App\Models\User;
use App\Models\AuditLog;
use App\Services\Stripe\StripeProductService;
use App\Services\Stripe\StripeSubscriptionService;
use App\Services\Subscription\SubscriptionService;
use App\Services\Payment\RefundService;
use Illuminate\Http\Request;
use Illuminate\Http\JsonResponse;
use Illuminate\Support\Facades\DB;

class AdminSubscriptionController extends Controller
{
    protected StripeProductService $productService;
    protected StripeSubscriptionService $stripeSubscription;
    protected SubscriptionService $subscriptionService;
    protected RefundService $refundService;

    public function __construct(
        StripeProductService $productService,
        StripeSubscriptionService $stripeSubscription,
        SubscriptionService $subscriptionService,
        RefundService $refundService
    ) {
        $this->productService = $productService;
        $this->stripeSubscription = $stripeSubscription;
        $this->subscriptionService = $subscriptionService;
        $this->refundService = $refundService;
    }

    /**
     * List all subscription plans.
     */
    public function listPlans(): JsonResponse
    {
        $plans = SubscriptionPlan::all();

        return response()->json([
            'success' => true,
            'data' => $plans,
        ]);
    }

    /**
     * Create a new subscription plan.
     */
    public function createPlan(Request $request): JsonResponse
    {
        $data = $request->validate([
            'name' => 'required|string|max:255',
            'slug' => 'required|string|max:100|unique:lce_subscription_plans,slug',
            'description' => 'nullable|string',
            'bags_per_day' => 'nullable|integer|min:1',
            'bags_per_week' => 'nullable|integer|min:1',
            'bags_per_month' => 'required|integer|min:1',
            'price_daily' => 'nullable|numeric|min:0',
            'price_weekly' => 'nullable|numeric|min:0',
            'price_monthly' => 'required|numeric|min:0',
            'price_annual' => 'nullable|numeric|min:0',
            'overage_policy' => 'nullable|in:block,charge_ppo',
            'overage_price_per_bag' => 'nullable|numeric|min:0',
            'is_active' => 'nullable|boolean',
        ]);

        $plan = SubscriptionPlan::create($data);

        return response()->json([
            'success' => true,
            'data' => $plan,
            'message' => 'Plan created. Use sync-to-stripe to enable Stripe billing.',
        ], 201);
    }

    /**
     * Update a subscription plan.
     */
    public function updatePlan(Request $request, int $id): JsonResponse
    {
        $plan = SubscriptionPlan::findOrFail($id);

        $data = $request->validate([
            'name' => 'sometimes|string|max:255',
            'description' => 'nullable|string',
            'bags_per_day' => 'nullable|integer|min:1',
            'bags_per_week' => 'nullable|integer|min:1',
            'bags_per_month' => 'sometimes|integer|min:1',
            'price_daily' => 'nullable|numeric|min:0',
            'price_weekly' => 'nullable|numeric|min:0',
            'price_monthly' => 'sometimes|numeric|min:0',
            'price_annual' => 'nullable|numeric|min:0',
            'overage_policy' => 'nullable|in:block,charge_ppo',
            'overage_price_per_bag' => 'nullable|numeric|min:0',
            'is_active' => 'nullable|boolean',
        ]);

        $plan->update($data);

        return response()->json([
            'success' => true,
            'data' => $plan->fresh(),
            'message' => 'Plan updated. Re-sync to Stripe if prices changed.',
        ]);
    }

    /**
     * Sync a plan to Stripe.
     */
    public function syncPlanToStripe(int $id): JsonResponse
    {
        $plan = SubscriptionPlan::findOrFail($id);

        try {
            $syncedPlan = $this->productService->syncPlanToStripe($plan);

            return response()->json([
                'success' => true,
                'data' => $syncedPlan,
                'message' => 'Plan synced to Stripe successfully.',
            ]);
        } catch (\Exception $e) {
            return response()->json([
                'success' => false,
                'message' => 'Failed to sync plan: ' . $e->getMessage(),
            ], 500);
        }
    }

    /**
     * Sync all active plans to Stripe.
     */
    public function syncAllPlansToStripe(): JsonResponse
    {
        try {
            $results = $this->productService->syncAllPlansToStripe();

            return response()->json([
                'success' => true,
                'data' => $results,
            ]);
        } catch (\Exception $e) {
            return response()->json([
                'success' => false,
                'message' => 'Failed to sync plans: ' . $e->getMessage(),
            ], 500);
        }
    }

    /**
     * List all user subscriptions with filters.
     */
    public function listSubscriptions(Request $request): JsonResponse
    {
        $query = UserSubscription::with(['user', 'plan']);

        if ($request->has('status')) {
            $query->where('status', $request->status);
        }

        if ($request->has('user_id')) {
            $query->where('user_id', $request->user_id);
        }

        if ($request->has('plan_id')) {
            $query->where('plan_id', $request->plan_id);
        }

        $subscriptions = $query->orderBy('created_at', 'desc')->paginate(20);

        return response()->json([
            'success' => true,
            'data' => $subscriptions,
        ]);
    }

    /**
     * Force upgrade a user's subscription.
     */
    public function forceUpgrade(Request $request, int $subscriptionId): JsonResponse
    {
        $data = $request->validate([
            'new_plan_id' => 'required|exists:lce_subscription_plans,id',
            'new_billing_cycle' => 'nullable|in:daily,weekly,monthly,annual',
        ]);

        $subscription = UserSubscription::findOrFail($subscriptionId);
        $newPlan = SubscriptionPlan::findOrFail($data['new_plan_id']);

        try {
            $upgraded = $this->subscriptionService->upgrade(
                $subscription,
                $newPlan,
                $data['new_billing_cycle'] ?? null
            );

            return response()->json([
                'success' => true,
                'data' => $upgraded->load('plan'),
                'message' => 'Subscription upgraded successfully.',
            ]);
        } catch (\Exception $e) {
            return response()->json([
                'success' => false,
                'message' => $e->getMessage(),
            ], 422);
        }
    }

    /**
     * Force downgrade a user's subscription (immediate with optional refund).
     */
    public function forceDowngrade(Request $request, int $subscriptionId): JsonResponse
    {
        $data = $request->validate([
            'new_plan_id' => 'required|exists:lce_subscription_plans,id',
            'new_billing_cycle' => 'nullable|in:daily,weekly,monthly,annual',
            'issue_refund' => 'nullable|boolean',
            'refund_amount' => 'nullable|numeric|min:0',
        ]);

        $subscription = UserSubscription::findOrFail($subscriptionId);
        $newPlan = SubscriptionPlan::findOrFail($data['new_plan_id']);

        try {
            return DB::transaction(function () use ($subscription, $newPlan, $data, $request) {
                // If immediate refund requested, process it first
                if (!empty($data['issue_refund']) && !empty($data['refund_amount'])) {
                    $invoice = $subscription->invoices()
                        ->where('status', 'paid')
                        ->latest()
                        ->first();

                    if ($invoice) {
                        $this->refundService->processPartialRefund(
                            $invoice,
                            $data['refund_amount'],
                            'Admin-initiated downgrade refund',
                            $request->user()
                        );
                    }
                }

                // Apply immediate downgrade
                $newCycle = $data['new_billing_cycle'] ?? $subscription->billing_cycle;
                $bagsForCycle = $newPlan->getBagsForCycle($newCycle);

                // Update in Stripe without proration (refund handled separately)
                if ($subscription->stripe_subscription_id) {
                    $this->stripeSubscription->updatePlan(
                        $subscription,
                        $newPlan,
                        $newCycle,
                        'none' // No proration, we handled refund manually
                    );
                }

                // Update local subscription
                $subscription->update([
                    'plan_id' => $newPlan->id,
                    'billing_cycle' => $newCycle,
                    'bags_plan_total' => $bagsForCycle,
                    'bags_plan_balance' => max(0, $bagsForCycle - $subscription->bags_plan_used),
                    'bags_available' => max(0, $bagsForCycle - $subscription->bags_plan_used),
                    'pending_plan_id' => null,
                    'pending_billing_cycle' => null,
                ]);

                // Audit log
                AuditLog::create([
                    'user_id' => $request->user()->id,
                    'action' => 'admin_force_downgrade',
                    'entity_type' => 'subscription',
                    'entity_id' => $subscription->id,
                    'metadata' => [
                        'new_plan_id' => $newPlan->id,
                        'refund_issued' => !empty($data['issue_refund']),
                        'refund_amount' => $data['refund_amount'] ?? null,
                    ],
                ]);

                return response()->json([
                    'success' => true,
                    'data' => $subscription->fresh()->load('plan'),
                    'message' => 'Subscription downgraded immediately.',
                ]);
            });
        } catch (\Exception $e) {
            return response()->json([
                'success' => false,
                'message' => $e->getMessage(),
            ], 422);
        }
    }

    /**
     * Apply manual proration to a subscription.
     */
    public function applyManualProration(Request $request, int $subscriptionId): JsonResponse
    {
        $data = $request->validate([
            'amount' => 'required|numeric',
            'reason' => 'required|string|max:500',
        ]);

        $subscription = UserSubscription::findOrFail($subscriptionId);

        try {
            $subscription->update([
                'manual_proration_applied' => true,
                'manual_proration_amount' => $data['amount'],
            ]);

            // Audit log
            AuditLog::create([
                'user_id' => $request->user()->id,
                'action' => 'admin_manual_proration',
                'entity_type' => 'subscription',
                'entity_id' => $subscription->id,
                'metadata' => [
                    'amount' => $data['amount'],
                    'reason' => $data['reason'],
                ],
            ]);

            return response()->json([
                'success' => true,
                'data' => $subscription->fresh(),
                'message' => 'Manual proration applied.',
            ]);
        } catch (\Exception $e) {
            return response()->json([
                'success' => false,
                'message' => $e->getMessage(),
            ], 422);
        }
    }

    /**
     * Cancel subscription immediately.
     */
    public function cancelImmediately(Request $request, int $subscriptionId): JsonResponse
    {
        $data = $request->validate([
            'reason' => 'nullable|string|max:500',
        ]);

        $subscription = UserSubscription::findOrFail($subscriptionId);

        try {
            return DB::transaction(function () use ($subscription, $data, $request) {
                // Cancel in Stripe immediately
                if ($subscription->stripe_subscription_id) {
                    $this->stripeSubscription->cancelImmediately($subscription);
                }

                // Update local subscription
                $subscription->update([
                    'status' => UserSubscription::STATUS_CANCELLED,
                    'cancelled_at' => now(),
                    'cancel_reason' => $data['reason'] ?? 'Admin cancellation',
                ]);

                // Remove from user
                if ($subscription->user->subscription_id === $subscription->id) {
                    $subscription->user->update(['subscription_id' => null]);
                }

                // Audit log
                AuditLog::create([
                    'user_id' => $request->user()->id,
                    'action' => 'admin_cancel_immediately',
                    'entity_type' => 'subscription',
                    'entity_id' => $subscription->id,
                    'metadata' => [
                        'reason' => $data['reason'] ?? 'Admin cancellation',
                    ],
                ]);

                return response()->json([
                    'success' => true,
                    'data' => $subscription->fresh(),
                    'message' => 'Subscription cancelled immediately.',
                ]);
            });
        } catch (\Exception $e) {
            return response()->json([
                'success' => false,
                'message' => $e->getMessage(),
            ], 422);
        }
    }

    /**
     * Get subscription billing history.
     */
    public function billingHistory(int $subscriptionId): JsonResponse
    {
        $subscription = UserSubscription::findOrFail($subscriptionId);

        $invoices = $subscription->invoices()
            ->with('lines')
            ->orderBy('created_at', 'desc')
            ->get();

        $auditLogs = AuditLog::where('entity_type', 'subscription')
            ->where('entity_id', $subscriptionId)
            ->orderBy('created_at', 'desc')
            ->limit(50)
            ->get();

        return response()->json([
            'success' => true,
            'data' => [
                'subscription' => $subscription->load('plan', 'user'),
                'invoices' => $invoices,
                'audit_logs' => $auditLogs,
            ],
        ]);
    }
}


================================================================================
SECTION: database/migrations
================================================================================

FILE: database/migrations/0001_01_01_000000_create_users_table.php
--------------------------------------------------------------------------------
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create('users', function (Blueprint $table) {
            $table->id();
            $table->string('name');
            $table->string('email')->unique();
            $table->timestamp('email_verified_at')->nullable();
            $table->string('password');
            $table->rememberToken();
            $table->timestamps();
        });

        Schema::create('password_reset_tokens', function (Blueprint $table) {
            $table->string('email')->primary();
            $table->string('token');
            $table->timestamp('created_at')->nullable();
        });

        Schema::create('sessions', function (Blueprint $table) {
            $table->string('id')->primary();
            $table->foreignId('user_id')->nullable()->index();
            $table->string('ip_address', 45)->nullable();
            $table->text('user_agent')->nullable();
            $table->longText('payload');
            $table->integer('last_activity')->index();
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists('users');
        Schema::dropIfExists('password_reset_tokens');
        Schema::dropIfExists('sessions');
    }
};

FILE: database/migrations/0001_01_01_000001_create_cache_table.php
--------------------------------------------------------------------------------
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create('cache', function (Blueprint $table) {
            $table->string('key')->primary();
            $table->mediumText('value');
            $table->integer('expiration');
        });

        Schema::create('cache_locks', function (Blueprint $table) {
            $table->string('key')->primary();
            $table->string('owner');
            $table->integer('expiration');
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists('cache');
        Schema::dropIfExists('cache_locks');
    }
};

FILE: database/migrations/0001_01_01_000002_create_jobs_table.php
--------------------------------------------------------------------------------
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create('jobs', function (Blueprint $table) {
            $table->id();
            $table->string('queue')->index();
            $table->longText('payload');
            $table->unsignedTinyInteger('attempts');
            $table->unsignedInteger('reserved_at')->nullable();
            $table->unsignedInteger('available_at');
            $table->unsignedInteger('created_at');
        });

        Schema::create('job_batches', function (Blueprint $table) {
            $table->string('id')->primary();
            $table->string('name');
            $table->integer('total_jobs');
            $table->integer('pending_jobs');
            $table->integer('failed_jobs');
            $table->longText('failed_job_ids');
            $table->mediumText('options')->nullable();
            $table->integer('cancelled_at')->nullable();
            $table->integer('created_at');
            $table->integer('finished_at')->nullable();
        });

        Schema::create('failed_jobs', function (Blueprint $table) {
            $table->id();
            $table->string('uuid')->unique();
            $table->text('connection');
            $table->text('queue');
            $table->longText('payload');
            $table->longText('exception');
            $table->timestamp('failed_at')->useCurrent();
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists('jobs');
        Schema::dropIfExists('job_batches');
        Schema::dropIfExists('failed_jobs');
    }
};

FILE: database/migrations/2025_12_22_113710_create_lce_subscription_plans_table.php
--------------------------------------------------------------------------------
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    public function up(): void
    {
        // Subscription Plans (the catalog of available plans)
        Schema::create('lce_subscription_plans', function (Blueprint $table) {
            $table->id();

            $table->string('name');
            $table->string('slug')->unique();
            $table->text('description')->nullable();

            $table->integer('bags_per_month');
            $table->decimal('price_monthly', 10, 2);
            $table->decimal('price_annual', 10, 2)->nullable();

            $table->boolean('is_active')->default(true);

            $table->timestamps();
        });
    }

    public function down(): void
    {
        Schema::dropIfExists('lce_subscription_plans');
    }
};

FILE: database/migrations/2025_12_22_114329_create_lce_user_subscriptions_table.php
--------------------------------------------------------------------------------
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    public function up(): void
    {
        Schema::create('lce_user_subscriptions', function (Blueprint $table) {
            $table->id();

            $table->unsignedBigInteger('user_id');
            $table->unsignedBigInteger('plan_id');

            $table->enum('status', [
                'pending',
                'active',
                'paused',
                'cancelled',
                'upgraded'
            ])->default('active');

            $table->enum('billing_cycle', ['monthly', 'annual']);

            $table->date('start_date')->nullable();
            $table->date('end_date')->nullable();
            $table->date('next_renewal_date')->nullable();

            $table->integer('bags_plan_period');
            $table->integer('bags_plan_total');
            $table->integer('bags_plan_balance')->default(0);
            $table->integer('bags_plan_used')->default(0);
            $table->integer('bags_available')->default(1);

            $table->decimal('payment_last', 10, 2)->default(0);
            $table->decimal('payment_discount', 10, 2)->default(0);
            $table->decimal('payment_balance', 10, 2)->default(0);

            $table->text('notes')->nullable();

            $table->timestamps();

            $table->index('user_id');
            $table->index('plan_id');
            $table->index('status');
        });
    }

    public function down(): void
    {
        Schema::dropIfExists('lce_user_subscriptions');
    }
};

FILE: database/migrations/2025_12_28_053934_create_lce_subscription_bag_usage_table.php
--------------------------------------------------------------------------------
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
  public function up()
{
    Schema::create('lce_subscription_bag_usage', function (Blueprint $table) {
        $table->id();

        $table->unsignedBigInteger('user_subscription_id');
        $table->unsignedBigInteger('pickup_id')->nullable();
        $table->unsignedBigInteger('invoice_id')->nullable();

        $table->integer('bags_used')->default(1);

        $table->timestamps();

        $table->index('user_subscription_id');
        $table->index('pickup_id');
        $table->index('invoice_id');
    });
}

public function down()
{
    Schema::dropIfExists('lce_subscription_bag_usage');
}

};

FILE: database/migrations/2025_12_28_094248_create_lce_user_credits_table.php
--------------------------------------------------------------------------------
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    public function up(): void
    {
        Schema::create('lce_user_credits', function (Blueprint $table) {
            $table->id();

            $table->unsignedBigInteger('user_id');

            $table->enum('type', [
                'welcome',
                'bonus',
                'promo',
                'referral',
                'compensation',
                'manual',
                'refund'
            ]);

            $table->string('description', 255);
            $table->decimal('amount', 10, 2);
            $table->decimal('balance', 10, 2);

            $table->timestamp('expires_at')->nullable();
            $table->boolean('used')->default(false);

            $table->timestamps();

            $table->index('user_id');
            $table->index('type');
        });
    }

    public function down(): void
    {
        Schema::dropIfExists('lce_user_credits');
    }
};

FILE: database/migrations/2025_12_28_102052_create_roles_table.php
--------------------------------------------------------------------------------
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up()
{
    Schema::create('roles', function (Blueprint $table) {
        $table->id();
        $table->string('name')->unique(); // admin, csr, ops, accounting
        $table->timestamps();
    });
}

public function down()
{
    Schema::dropIfExists('roles');
}

};

FILE: database/migrations/2025_12_28_102247_create_user_roles_table.php
--------------------------------------------------------------------------------
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    public function up()
{
    Schema::create('user_roles', function (Blueprint $table) {
        $table->id();

        $table->unsignedBigInteger('user_id');
        $table->unsignedBigInteger('role_id');

        $table->timestamps();

        $table->index('user_id');
        $table->index('role_id');
        $table->unique(['user_id', 'role_id']);
    });
}

public function down()
{
    Schema::dropIfExists('user_roles');
}

};

FILE: database/migrations/2025_12_29_062158_create_lce_user_info_table.php
--------------------------------------------------------------------------------
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    public function up(): void
    {
        Schema::create('lce_user_info', function (Blueprint $table) {
            $table->id();

            $table->string('email')->unique();
            $table->string('password');

            $table->string('first_name')->nullable();
            $table->string('last_name')->nullable();
            $table->string('phone')->nullable();

            $table->enum('default_order_type', ['ppo', 'subscription'])->default('ppo');
            $table->unsignedBigInteger('subscription_id')->nullable();

            $table->timestamps();

            $table->index('subscription_id');
        });
    }

    public function down(): void
    {
        Schema::dropIfExists('lce_user_info');
    }
};

FILE: database/migrations/2025_12_29_082119_create_invoices_table.php
--------------------------------------------------------------------------------
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration {
    public function up(): void
    {
        Schema::create('invoices', function (Blueprint $table) {
            $table->id();

            $table->unsignedBigInteger('user_id');
            $table->unsignedBigInteger('pickup_id')->nullable();
            $table->unsignedBigInteger('subscription_id')->nullable();

            $table->string('type');   // ppo, subscription_overage, refund
            $table->string('status'); // draft, pending_payment, paid, refunded

            $table->string('currency', 3)->default('USD');

            $table->decimal('subtotal', 10, 2);
            $table->decimal('tax', 10, 2)->default(0);
            $table->decimal('total', 10, 2);

            $table->json('metadata')->nullable();

            $table->timestamp('issued_at')->nullable();
            $table->timestamp('paid_at')->nullable();
            $table->timestamp('refunded_at')->nullable();

            $table->timestamps();

            $table->index('user_id');
            $table->index('pickup_id');
            $table->index('status');
        });
    }

    public function down(): void
    {
        Schema::dropIfExists('invoices');
    }
};

FILE: database/migrations/2025_12_29_082120_create_invoice_lines_table.php
--------------------------------------------------------------------------------
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration {
    public function up(): void
    {
        Schema::create('invoice_lines', function (Blueprint $table) {
            $table->id();

            $table->unsignedBigInteger('invoice_id');

            $table->string('type'); // weight, fee, credit, overage
            $table->string('description');

            $table->decimal('quantity', 10, 2);
            $table->decimal('unit_price', 10, 2);
            $table->decimal('amount', 10, 2);

            $table->timestamps();

            $table->foreign('invoice_id')
                ->references('id')
                ->on('invoices')
                ->onDelete('cascade');
        });
    }

    public function down(): void
    {
        Schema::dropIfExists('invoice_lines');
    }
};

FILE: database/migrations/2025_12_30_113022_create_personal_access_tokens_table.php
--------------------------------------------------------------------------------
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create('personal_access_tokens', function (Blueprint $table) {
            $table->id();
            $table->morphs('tokenable');
            $table->text('name');
            $table->string('token', 64)->unique();
            $table->text('abilities')->nullable();
            $table->timestamp('last_used_at')->nullable();
            $table->timestamp('expires_at')->nullable()->index();
            $table->timestamps();
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists('personal_access_tokens');
    }
};

FILE: database/migrations/2025_12_31_100127_add_indexes_for_performance.php
--------------------------------------------------------------------------------
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;
use Illuminate\Support\Facades\DB;

return new class extends Migration {
    public function up(): void
    {
        // Check and add composite index on invoices (status, created_at)
        if (!$this->indexExists('invoices', 'invoices_status_created_at_index')) {
            Schema::table('invoices', function (Blueprint $table) {
                $table->index(['status', 'created_at'], 'invoices_status_created_at_index');
            });
        }

        // user_id index likely already exists from foreign key
        // Only add if not present
        if (
            !$this->indexExists('invoices', 'invoices_user_id_index') &&
            !$this->indexExists('invoices', 'invoices_user_id_foreign')
        ) {
            Schema::table('invoices', function (Blueprint $table) {
                $table->index('user_id', 'invoices_user_id_index');
            });
        }
    }

    public function down(): void
    {
        if ($this->indexExists('invoices', 'invoices_status_created_at_index')) {
            Schema::table('invoices', function (Blueprint $table) {
                $table->dropIndex('invoices_status_created_at_index');
            });
        }
    }

    /**
     * Check if an index exists on a table.
     */
    private function indexExists(string $table, string $indexName): bool
    {
        $indexes = DB::select("SHOW INDEX FROM `$table` WHERE Key_name = ?", [$indexName]);
        return count($indexes) > 0;
    }
};

FILE: database/migrations/2025_12_31_100335_create_pickups_table.php
--------------------------------------------------------------------------------
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration {
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create('pickups', function (Blueprint $table) {
            $table->id();

            // Foreign keys
            $table->foreignId('user_id')->constrained('lce_user_info')->onDelete('cascade');
            $table->foreignId('subscription_id')->nullable()->constrained('lce_user_subscriptions')->onDelete('set null');
            $table->foreignId('invoice_id')->nullable()->constrained('invoices')->onDelete('set null');

            // Pickup details
            $table->enum('order_type', ['ppo', 'subscription'])->default('ppo');
            $table->enum('status', [
                'pending_payment',
                'scheduled',
                'picked_up',
                'processing',
                'ready_for_delivery',
                'delivered',
                'cancelled'
            ])->default('pending_payment');

            $table->date('pickup_date')->nullable();
            $table->decimal('estimated_weight', 8, 2)->nullable();
            $table->decimal('actual_weight', 8, 2)->nullable();
            $table->integer('bags_used')->nullable();

            // Address info
            $table->text('pickup_address')->nullable();
            $table->text('delivery_address')->nullable();
            $table->text('notes')->nullable();

            // Timestamps
            $table->timestamp('picked_up_at')->nullable();
            $table->timestamp('delivered_at')->nullable();
            $table->timestamps();

            // Indexes for performance
            $table->index('pickup_date');
            $table->index('status');
            $table->index(['status', 'pickup_date']);
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists('pickups');
    }
};

FILE: database/migrations/2026_01_01_050652_create_audit_logs_table.php
--------------------------------------------------------------------------------
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration {
    public function up(): void
    {
        Schema::create('audit_logs', function (Blueprint $table) {
            $table->id();

            $table->foreignId('user_id')->nullable(); // admin or system
            $table->string('action');                 // e.g. invoice_refund
            $table->string('entity_type');            // e.g. invoice
            $table->unsignedBigInteger('entity_id');  // invoice_id
            $table->json('metadata')->nullable();     // reason, old/new values

            $table->timestamps();

            $table->index(['entity_type', 'entity_id']);
            $table->index('action');
        });
    }

    public function down(): void
    {
        Schema::dropIfExists('audit_logs');
    }
};

FILE: database/migrations/2026_01_01_143000_create_stripe_customers_table.php
--------------------------------------------------------------------------------
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    public function up(): void
    {
        Schema::create('stripe_customers', function (Blueprint $table) {
            $table->id();
            $table->foreignId('user_id')->constrained('lce_user_info')->onDelete('cascade');
            $table->string('stripe_customer_id')->unique();
            $table->timestamps();

            $table->index('stripe_customer_id');
        });
    }

    public function down(): void
    {
        Schema::dropIfExists('stripe_customers');
    }
};

FILE: database/migrations/2026_01_01_143001_create_payments_table.php
--------------------------------------------------------------------------------
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    public function up(): void
    {
        Schema::create('payments', function (Blueprint $table) {
            $table->id();
            $table->foreignId('invoice_id')->constrained('invoices')->onDelete('cascade');
            $table->foreignId('user_id')->constrained('lce_user_info')->onDelete('cascade');

            $table->decimal('amount', 10, 2);
            $table->string('currency', 3)->default('USD');

            $table->enum('status', [
                'pending',
                'processing',
                'succeeded',
                'failed',
                'refunded',
                'partially_refunded'
            ])->default('pending');

            $table->string('stripe_payment_intent_id')->nullable()->unique();
            $table->string('stripe_refund_id')->nullable();

            $table->json('metadata')->nullable();
            $table->text('failure_reason')->nullable();

            $table->timestamp('paid_at')->nullable();
            $table->timestamp('refunded_at')->nullable();
            $table->timestamps();

            $table->index('stripe_payment_intent_id');
            $table->index('status');
            $table->index(['invoice_id', 'status']);
        });
    }

    public function down(): void
    {
        Schema::dropIfExists('payments');
    }
};

FILE: database/migrations/2026_01_01_143002_create_stripe_webhook_events_table.php
--------------------------------------------------------------------------------
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    public function up(): void
    {
        Schema::create('stripe_webhook_events', function (Blueprint $table) {
            $table->id();
            $table->string('stripe_event_id')->unique();
            $table->string('type');
            $table->json('payload');
            $table->timestamp('processed_at')->nullable();
            $table->timestamps();

            $table->index('stripe_event_id');
            $table->index('type');
        });
    }

    public function down(): void
    {
        Schema::dropIfExists('stripe_webhook_events');
    }
};

FILE: database/migrations/2026_01_02_120000_add_stripe_ids_to_subscription_plans.php
--------------------------------------------------------------------------------
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    public function up(): void
    {
        Schema::table('lce_subscription_plans', function (Blueprint $table) {
            // Stripe Product ID
            $table->string('stripe_product_id')->nullable()->after('is_active');

            // Stripe Price IDs for each billing cycle
            $table->string('stripe_price_id_daily')->nullable()->after('stripe_product_id');
            $table->string('stripe_price_id_weekly')->nullable()->after('stripe_price_id_daily');
            $table->string('stripe_price_id_monthly')->nullable()->after('stripe_price_id_weekly');
            $table->string('stripe_price_id_annual')->nullable()->after('stripe_price_id_monthly');

            // Pricing for daily and weekly (monthly and annual already exist)
            $table->decimal('price_daily', 10, 2)->nullable()->after('description');
            $table->decimal('price_weekly', 10, 2)->nullable()->after('price_daily');

            // Bag allocations per billing cycle
            $table->integer('bags_per_day')->nullable()->after('bags_per_month');
            $table->integer('bags_per_week')->nullable()->after('bags_per_day');

            // Overage policy: block pickup or charge PPO
            $table->enum('overage_policy', ['block', 'charge_ppo'])->default('block')->after('is_active');

            // PPO price for overage charges (when overage_policy = 'charge_ppo')
            $table->decimal('overage_price_per_bag', 10, 2)->nullable()->after('overage_policy');
        });
    }

    public function down(): void
    {
        Schema::table('lce_subscription_plans', function (Blueprint $table) {
            $table->dropColumn([
                'stripe_product_id',
                'stripe_price_id_daily',
                'stripe_price_id_weekly',
                'stripe_price_id_monthly',
                'stripe_price_id_annual',
                'price_daily',
                'price_weekly',
                'bags_per_day',
                'bags_per_week',
                'overage_policy',
                'overage_price_per_bag',
            ]);
        });
    }
};

FILE: database/migrations/2026_01_02_120001_add_stripe_ids_to_user_subscriptions.php
--------------------------------------------------------------------------------
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;
use Illuminate\Support\Facades\DB;

return new class extends Migration
{
    public function up(): void
    {
        Schema::table('lce_user_subscriptions', function (Blueprint $table) {
            // Stripe Subscription ID
            $table->string('stripe_subscription_id')->nullable()->unique()->after('plan_id');
            $table->string('stripe_customer_id')->nullable()->after('stripe_subscription_id');

            // Stripe billing period tracking
            $table->timestamp('current_period_start')->nullable()->after('next_renewal_date');
            $table->timestamp('current_period_end')->nullable()->after('current_period_start');

            // Cancellation tracking
            $table->boolean('cancel_at_period_end')->default(false)->after('status');
            $table->string('cancel_reason')->nullable()->after('cancel_at_period_end');
            $table->timestamp('cancelled_at')->nullable()->after('cancel_reason');

            // Pending plan change (for scheduled downgrades)
            $table->unsignedBigInteger('pending_plan_id')->nullable()->after('plan_id');
            $table->string('pending_billing_cycle')->nullable()->after('pending_plan_id');

            // Proration tracking
            $table->boolean('manual_proration_applied')->default(false)->after('payment_balance');
            $table->decimal('manual_proration_amount', 10, 2)->nullable()->after('manual_proration_applied');
        });

        // Update billing_cycle enum to include daily/weekly
        // MySQL doesn't allow direct enum modification, so we use raw SQL
        DB::statement("ALTER TABLE lce_user_subscriptions MODIFY COLUMN billing_cycle ENUM('daily', 'weekly', 'monthly', 'annual') DEFAULT 'monthly'");

        // Update status enum to include more states
        DB::statement("ALTER TABLE lce_user_subscriptions MODIFY COLUMN status ENUM('pending', 'active', 'paused', 'past_due', 'cancelled', 'upgraded', 'downgraded') DEFAULT 'pending'");
    }

    public function down(): void
    {
        Schema::table('lce_user_subscriptions', function (Blueprint $table) {
            $table->dropColumn([
                'stripe_subscription_id',
                'stripe_customer_id',
                'current_period_start',
                'current_period_end',
                'cancel_at_period_end',
                'cancel_reason',
                'cancelled_at',
                'pending_plan_id',
                'pending_billing_cycle',
                'manual_proration_applied',
                'manual_proration_amount',
            ]);
        });

        // Revert enum changes
        DB::statement("ALTER TABLE lce_user_subscriptions MODIFY COLUMN billing_cycle ENUM('monthly', 'annual') DEFAULT 'monthly'");
        DB::statement("ALTER TABLE lce_user_subscriptions MODIFY COLUMN status ENUM('pending', 'active', 'paused', 'cancelled', 'upgraded') DEFAULT 'active'");
    }
};

FILE: database/migrations/2026_01_02_120002_add_stripe_invoice_id_to_invoices.php
--------------------------------------------------------------------------------
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    public function up(): void
    {
        // Add stripe_invoice_id if not exists
        if (!Schema::hasColumn('invoices', 'stripe_invoice_id')) {
            Schema::table('invoices', function (Blueprint $table) {
                $table->string('stripe_invoice_id')->nullable()->unique()->after('id');
            });
        }
    }

    public function down(): void
    {
        if (Schema::hasColumn('invoices', 'stripe_invoice_id')) {
            Schema::table('invoices', function (Blueprint $table) {
                $table->dropColumn('stripe_invoice_id');
            });
        }
    }
};

FILE: database/migrations/2026_01_02_133333_add_stripe_schedule_id_to_user_subscriptions.php
--------------------------------------------------------------------------------
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Add stripe_schedule_id to track subscription schedules.
     * This prevents duplicate schedules and orphaned Stripe objects.
     */
    public function up(): void
    {
        Schema::table('lce_user_subscriptions', function (Blueprint $table) {
            // Store Stripe subscription schedule ID for downgrades/plan changes
            $table->string('stripe_schedule_id')->nullable()->after('stripe_customer_id');

            // Index for quick lookup
            $table->index('stripe_schedule_id');
        });
    }

    public function down(): void
    {
        Schema::table('lce_user_subscriptions', function (Blueprint $table) {
            $table->dropIndex(['stripe_schedule_id']);
            $table->dropColumn('stripe_schedule_id');
        });
    }
};


================================================================================
SECTION: routes/api.php
================================================================================

FILE: routes/api.php
--------------------------------------------------------------------------------
<?php

use Illuminate\Support\Facades\Route;
use App\Http\Controllers\HealthController;
use App\Http\Controllers\Api\V1\AuthController;
use App\Http\Controllers\Api\V1\SubscriptionController;
use App\Http\Controllers\Api\V1\PickupController;
use App\Http\Controllers\Api\V1\CreditController;
use App\Http\Controllers\Api\V1\BillingController;
use App\Http\Controllers\Api\V1\InvoiceController;
use App\Http\Controllers\Api\V1\PaymentController;
use App\Http\Controllers\Api\V1\StripeWebhookController;
use App\Http\Controllers\Api\V1\Admin\AdminInvoiceController;
use App\Http\Controllers\Api\V1\Admin\AdminDashboardController;
use App\Http\Controllers\Api\V1\Admin\AdminSubscriptionController;


/*
|--------------------------------------------------------------------------
| Health Check (Public)
|--------------------------------------------------------------------------
*/

Route::get('/health', HealthController::class);

/*
|--------------------------------------------------------------------------
| Public Auth Routes (Strict Rate Limit)
|--------------------------------------------------------------------------
*/

Route::prefix('v1/auth')
    ->middleware('throttle:10,1') // 10 requests per minute for auth
    ->group(function () {
        Route::post('/register', [AuthController::class, 'register']);
        Route::post('/login', [AuthController::class, 'login']);
    });


/*
|--------------------------------------------------------------------------
| Protected Routes (Auth + API Rate Limit)
|--------------------------------------------------------------------------
*/

Route::prefix('v1')
    ->middleware(['auth:sanctum', 'throttle:api'])
    ->group(function () {

        // Auth (protected)
        Route::post('/auth/logout', [AuthController::class, 'logout']);
        Route::get('/auth/me', [AuthController::class, 'me']);

        // Pickups
        Route::post('/pickups/preview', [PickupController::class, 'preview']);
        Route::post('/pickups/confirm', [PickupController::class, 'confirm']);
        Route::put('/pickups/{id}', [PickupController::class, 'update']);

        // Subscriptions
        Route::get('/subscriptions/plans', [SubscriptionController::class, 'plans']);
        Route::get('/subscriptions/current', [SubscriptionController::class, 'current']);
        Route::get('/subscriptions/check-pickup', [SubscriptionController::class, 'checkPickup']);
        Route::post('/subscriptions', [SubscriptionController::class, 'store']);
        Route::post('/subscriptions/{id}/cancel', [SubscriptionController::class, 'cancel']);
        Route::post('/subscriptions/{id}/reactivate', [SubscriptionController::class, 'reactivate']);
        Route::post('/subscriptions/{id}/pause', [SubscriptionController::class, 'pause']);
        Route::post('/subscriptions/{id}/resume', [SubscriptionController::class, 'resume']);
        Route::post('/subscriptions/{id}/upgrade', [SubscriptionController::class, 'upgrade']);
        Route::post('/subscriptions/{id}/downgrade', [SubscriptionController::class, 'downgrade']);

        // Billing
        Route::post('/billing/ppo/preview', [BillingController::class, 'ppoPreview']);

        // Credits
        Route::get('/credits', [CreditController::class, 'index']);

        // Invoices (customer)
        Route::get('/invoices', [InvoiceController::class, 'index']);
        Route::get('/invoices/{invoice}', [InvoiceController::class, 'show']);
        Route::post('/invoices/{invoice}/pay', [InvoiceController::class, 'pay']);

        // Payments
        Route::post('/payments/intent', [PaymentController::class, 'createIntent']);
        Route::get('/payments/status/{invoice}', [PaymentController::class, 'status']);
    });


/*
|--------------------------------------------------------------------------
| Stripe Webhook (No Auth - Uses Signature Verification)
|--------------------------------------------------------------------------
*/

Route::post('/v1/webhooks/stripe', [StripeWebhookController::class, 'handle'])
    ->withoutMiddleware(['throttle:api']);


/*
|--------------------------------------------------------------------------
| Admin Routes (Auth + Admin Role + Stricter Rate Limit)
|--------------------------------------------------------------------------
*/

Route::prefix('v1/admin')
    ->middleware(['auth:sanctum', 'role:admin', 'throttle:30,1']) // 30 requests per minute
    ->group(function () {

        // Admin Invoices
        Route::get('/invoices', [AdminInvoiceController::class, 'index']);
        Route::get('/invoices/export', [AdminInvoiceController::class, 'export']);
        Route::post('/invoices/{invoice}/refund', [AdminInvoiceController::class, 'refund']);

        // Admin Dashboard
        Route::get('/dashboard/summary', [AdminDashboardController::class, 'summary']);
        Route::get('/dashboard/revenue', [AdminDashboardController::class, 'revenue']);

        // Admin Subscription Plans
        Route::get('/subscription-plans', [AdminSubscriptionController::class, 'listPlans']);
        Route::post('/subscription-plans', [AdminSubscriptionController::class, 'createPlan']);
        Route::put('/subscription-plans/{id}', [AdminSubscriptionController::class, 'updatePlan']);
        Route::post('/subscription-plans/{id}/sync', [AdminSubscriptionController::class, 'syncPlanToStripe']);
        Route::post('/subscription-plans/sync-all', [AdminSubscriptionController::class, 'syncAllPlansToStripe']);

        // Admin Subscriptions
        Route::get('/subscriptions', [AdminSubscriptionController::class, 'listSubscriptions']);
        Route::get('/subscriptions/{id}/history', [AdminSubscriptionController::class, 'billingHistory']);
        Route::post('/subscriptions/{id}/upgrade', [AdminSubscriptionController::class, 'forceUpgrade']);
        Route::post('/subscriptions/{id}/downgrade', [AdminSubscriptionController::class, 'forceDowngrade']);
        Route::post('/subscriptions/{id}/proration', [AdminSubscriptionController::class, 'applyManualProration']);
        Route::post('/subscriptions/{id}/cancel', [AdminSubscriptionController::class, 'cancelImmediately']);
    });

================================================================================
SECTION: app/Console/Commands
================================================================================

FILE: app/Console/Commands/ReconcileSubscriptionsCommand.php
--------------------------------------------------------------------------------
<?php

namespace App\Console\Commands;

use App\Models\UserSubscription;
use App\Models\Invoice;
use App\Models\AuditLog;
use App\Services\Stripe\StripeSubscriptionService;
use Illuminate\Console\Command;
use Illuminate\Support\Facades\Log;
use Stripe\StripeClient;
use Carbon\Carbon;

class ReconcileSubscriptionsCommand extends Command
{
    protected $signature = 'subscriptions:reconcile 
                            {--dry-run : Show what would be done without making changes}
                            {--force : Force reconciliation even for recently synced}';

    protected $description = 'Reconcile local subscriptions with Stripe to catch missed webhooks and data drift';

    protected StripeClient $stripe;
    protected bool $dryRun = false;
    protected int $synced = 0;
    protected int $errors = 0;

    public function __construct()
    {
        parent::__construct();
        $this->stripe = new StripeClient(config('stripe.secret'));
    }

    public function handle(): int
    {
        $this->dryRun = $this->option('dry-run');

        $this->info(' Starting subscription reconciliation...');
        if ($this->dryRun) {
            $this->warn('   Running in DRY-RUN mode - no changes will be made');
        }

        // Get all active/pending subscriptions linked to Stripe
        $subscriptions = UserSubscription::whereNotNull('stripe_subscription_id')
            ->whereIn('status', [
                UserSubscription::STATUS_PENDING,
                UserSubscription::STATUS_ACTIVE,
                UserSubscription::STATUS_PAUSED,
                UserSubscription::STATUS_PAST_DUE,
            ])
            ->get();

        $this->info("   Found {$subscriptions->count()} subscriptions to check");

        $bar = $this->output->createProgressBar($subscriptions->count());
        $bar->start();

        foreach ($subscriptions as $subscription) {
            try {
                $this->reconcileSubscription($subscription);
            } catch (\Exception $e) {
                $this->errors++;
                Log::error('Reconciliation failed for subscription', [
                    'subscription_id' => $subscription->id,
                    'error' => $e->getMessage(),
                ]);
            }
            $bar->advance();
        }

        $bar->finish();
        $this->newLine(2);

        // Check for expired subscriptions
        $this->checkExpiredSubscriptions();

        // Summary
        $this->info(" Reconciliation complete:");
        $this->info("   - Synced: {$this->synced}");
        $this->info("   - Errors: {$this->errors}");

        return $this->errors > 0 ? Command::FAILURE : Command::SUCCESS;
    }

    protected function reconcileSubscription(UserSubscription $subscription): void
    {
        try {
            $stripeSubscription = $this->stripe->subscriptions->retrieve(
                $subscription->stripe_subscription_id,
                ['expand' => ['latest_invoice']]
            );
        } catch (\Stripe\Exception\InvalidRequestException $e) {
            // Subscription no longer exists in Stripe
            if (str_contains($e->getMessage(), 'No such subscription')) {
                $this->handleDeletedSubscription($subscription);
                return;
            }
            throw $e;
        }

        $changes = [];

        // Check status mismatch
        $localStatus = $subscription->status;
        $stripeStatus = $this->mapStripeStatus($stripeSubscription->status);

        if ($localStatus !== $stripeStatus) {
            $changes['status'] = $stripeStatus;
        }

        // Check period dates (only if Stripe has them)
        if ($stripeSubscription->current_period_start && $stripeSubscription->current_period_end) {
            $stripePeriodStart = Carbon::createFromTimestamp($stripeSubscription->current_period_start);
            $stripePeriodEnd = Carbon::createFromTimestamp($stripeSubscription->current_period_end);

            if (
                !$subscription->current_period_start ||
                $subscription->current_period_start->timestamp !== $stripePeriodStart->timestamp
            ) {
                $changes['current_period_start'] = $stripePeriodStart;
            }

            if (
                !$subscription->current_period_end ||
                $subscription->current_period_end->timestamp !== $stripePeriodEnd->timestamp
            ) {
                $changes['current_period_end'] = $stripePeriodEnd;
            }
        }

        // Check cancellation status
        if ($stripeSubscription->cancel_at_period_end !== $subscription->cancel_at_period_end) {
            $changes['cancel_at_period_end'] = $stripeSubscription->cancel_at_period_end;
        }

        // Apply changes
        if (!empty($changes)) {
            if (!$this->dryRun) {
                $subscription->update($changes);

                AuditLog::create([
                    'user_id' => $subscription->user_id,
                    'action' => 'subscription_reconciled',
                    'entity_type' => 'subscription',
                    'entity_id' => $subscription->id,
                    'metadata' => [
                        'changes' => $changes,
                        'stripe_status' => $stripeSubscription->status,
                    ],
                ]);
            }

            $this->synced++;
            $this->line("\n   Updated subscription #{$subscription->id}: " . json_encode(array_keys($changes)));
        }

        // Check for missing invoices
        $this->reconcileInvoices($subscription, $stripeSubscription);
    }

    protected function reconcileInvoices(UserSubscription $subscription, \Stripe\Subscription $stripeSubscription): void
    {
        // Get recent Stripe invoices for this subscription
        $stripeInvoices = $this->stripe->invoices->all([
            'subscription' => $subscription->stripe_subscription_id,
            'limit' => 10,
        ]);

        foreach ($stripeInvoices->data as $stripeInvoice) {
            // Check if we have this invoice locally
            $localInvoice = Invoice::where('stripe_invoice_id', $stripeInvoice->id)->first();

            if (!$localInvoice && $stripeInvoice->status === 'paid') {
                // Missing paid invoice - create it
                if (!$this->dryRun) {
                    $this->createMissingInvoice($subscription, $stripeInvoice);
                }
                $this->line("\n   Created missing invoice: {$stripeInvoice->id}");
                $this->synced++;
            } elseif ($localInvoice && $this->invoiceNeedsUpdate($localInvoice, $stripeInvoice)) {
                // Invoice status mismatch
                if (!$this->dryRun) {
                    $localInvoice->update([
                        'status' => $this->mapInvoiceStatus($stripeInvoice->status),
                        'paid_at' => $stripeInvoice->status === 'paid' ? now() : null,
                    ]);
                }
                $this->line("\n   Updated invoice status: {$stripeInvoice->id}");
                $this->synced++;
            }
        }
    }

    protected function createMissingInvoice(UserSubscription $subscription, \Stripe\Invoice $stripeInvoice): void
    {
        Invoice::create([
            'stripe_invoice_id' => $stripeInvoice->id,
            'user_id' => $subscription->user_id,
            'subscription_id' => $subscription->id,
            'type' => 'subscription',
            'status' => $this->mapInvoiceStatus($stripeInvoice->status),
            'currency' => strtoupper($stripeInvoice->currency),
            'subtotal' => $stripeInvoice->subtotal / 100,
            'tax' => $stripeInvoice->tax ? $stripeInvoice->tax / 100 : 0,
            'total' => $stripeInvoice->total / 100,
            'issued_at' => Carbon::createFromTimestamp($stripeInvoice->created),
            'paid_at' => $stripeInvoice->status === 'paid' ? now() : null,
            'metadata' => ['source' => 'reconciliation'],
        ]);
    }

    protected function invoiceNeedsUpdate(Invoice $local, \Stripe\Invoice $stripe): bool
    {
        $expectedStatus = $this->mapInvoiceStatus($stripe->status);
        return $local->status !== $expectedStatus;
    }

    protected function mapInvoiceStatus(string $stripeStatus): string
    {
        return match ($stripeStatus) {
            'paid' => 'paid',
            'open' => 'pending_payment',
            'void' => 'cancelled',
            'uncollectible' => 'payment_failed',
            default => 'pending',
        };
    }

    protected function handleDeletedSubscription(UserSubscription $subscription): void
    {
        if ($subscription->status !== UserSubscription::STATUS_CANCELLED) {
            if (!$this->dryRun) {
                $subscription->update([
                    'status' => UserSubscription::STATUS_CANCELLED,
                    'cancelled_at' => now(),
                ]);

                if ($subscription->user->subscription_id === $subscription->id) {
                    $subscription->user->update(['subscription_id' => null]);
                }

                AuditLog::create([
                    'user_id' => $subscription->user_id,
                    'action' => 'subscription_cancelled_via_reconciliation',
                    'entity_type' => 'subscription',
                    'entity_id' => $subscription->id,
                    'metadata' => ['reason' => 'Subscription deleted in Stripe'],
                ]);
            }

            $this->synced++;
            $this->warn("\n   Subscription #{$subscription->id} deleted in Stripe - marked as cancelled");
        }
    }

    protected function checkExpiredSubscriptions(): void
    {
        $this->info(' Checking for expired subscriptions...');

        // Find subscriptions past their period end that are still active
        $expired = UserSubscription::where('status', UserSubscription::STATUS_ACTIVE)
            ->where('cancel_at_period_end', true)
            ->where('current_period_end', '<', now())
            ->get();

        foreach ($expired as $subscription) {
            if (!$this->dryRun) {
                $subscription->update([
                    'status' => UserSubscription::STATUS_CANCELLED,
                    'cancelled_at' => $subscription->current_period_end,
                ]);

                if ($subscription->user->subscription_id === $subscription->id) {
                    $subscription->user->update(['subscription_id' => null]);
                }
            }

            $this->synced++;
            $this->line("   Expired subscription #{$subscription->id} marked as cancelled");
        }

        $this->info("   Found {$expired->count()} expired subscriptions");
    }

    protected function mapStripeStatus(string $stripeStatus): string
    {
        return match ($stripeStatus) {
            'active' => UserSubscription::STATUS_ACTIVE,
            'past_due' => UserSubscription::STATUS_PAST_DUE,
            'canceled' => UserSubscription::STATUS_CANCELLED,
            'paused' => UserSubscription::STATUS_PAUSED,
            'incomplete', 'incomplete_expired' => UserSubscription::STATUS_PENDING,
            default => UserSubscription::STATUS_PENDING,
        };
    }
}

